<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Cycle Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f5ff;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }
        
        .simulation {
            position: relative;
            width: 100%;
            height: 500px;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #4682B4);
            transition: background 3s;
        }
        
        .controls {
            margin-top: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .control-row {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        
        .control-group {
            flex: 1;
            min-width: 250px;
            margin: 0 10px 10px 0;
        }
        
        .control-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
            color: #34495e;
        }
        
        .control-group input {
            width: 100%;
        }
        
        .value-display {
            color: #7f8c8d;
            font-size: 13px;
        }
        
        .reset-btn {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .reset-btn:hover {
            background-color: #2980b9;
        }
        
        .cloud {
            position: absolute;
            top: 20px;
            width: 100%;
            height: 60px;
            display: flex;
            justify-content: space-around;
        }
        
        .cloud-part {
            position: relative;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 20px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
        }
        
        .ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            display: flex;
        }
        
        .terrain {
            position: relative;
            border-top-right-radius: 5px;
            background-color: #8B4513;
        }
        
        .pool {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(30, 144, 255, 0.7);
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            transition: height 0.5s;
        }
        
        .raindrop {
            position: absolute;
            width: 2px;
            height: 10px;
            background-color: #1E90FF;
            border-radius: 0 0 2px 2px;
        }
        
        .vapor {
            position: absolute;
            width: 3px;
            height: 3px;
            background-color: rgba(200, 200, 200, 0.7);
            border-radius: 50%;
        }
        
        .downflow {
            position: absolute;
            width: 5px;
            height: 5px;
            background-color: rgba(30, 144, 255, 0.9);
            border-radius: 50%;
        }
        
        .metrics {
            margin-top: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .metrics-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .metrics-container {
            display: flex;
            flex-wrap: wrap;
        }
        
        .metric {
            flex: 1;
            min-width: 150px;
            margin-right: 15px;
            margin-bottom: 10px;
        }
        
        .metric-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
            color: #34495e;
        }
        
        .metric-bar-container {
            width: 100%;
            height: 15px;
            background-color: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .metric-bar {
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s;
        }
        
        .time-indicator {
            position: absolute;
            top: 10px;
            right: 20px;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            background-color: rgba(0, 0, 0, 0.4);
        }
        
        .temperature-indicator {
            position: absolute;
            top: 45px;
            right: 20px;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            background-color: rgba(0, 0, 0, 0.4);
        }
        
        .sun-moon {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            top: 30px;
            transition: left 3s, background-color 3s, box-shadow 3s;
        }
        
        .debug-info {
            margin-top: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-family: monospace;
            font-size: 12px;
            white-space: pre;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Water Cycle Simulation</h1>
        
        <div class="simulation" id="simulation">
            <div class="cloud" id="cloud"></div>
            <div class="ground" id="ground"></div>
            <div class="time-indicator" id="timeIndicator">Day</div>
            <div class="temperature-indicator" id="temperatureIndicator">25°C</div>
            <div class="sun-moon" id="sunMoon"></div>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label>
                        Time Speed
                        <span class="value-display" id="timeSpeedValue">1.0x</span>
                    </label>
                    <input type="range" id="timeSpeed" min="0.1" max="5" step="0.1" value="1">
                </div>
                
                <div class="control-group">
                    <label>
                        Day Temperature
                        <span class="value-display" id="dayTempValue">25°C</span>
                    </label>
                    <input type="range" id="dayTemp" min="10" max="40" step="1" value="25">
                </div>
                
                <div class="control-group">
                    <label>
                        Night Temperature
                        <span class="value-display" id="nightTempValue">15°C</span>
                    </label>
                    <input type="range" id="nightTemp" min="0" max="30" step="1" value="15">
                </div>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <label>
                        Evaporation Rate
                        <span class="value-display" id="evapRateValue">1.0x</span>
                    </label>
                    <input type="range" id="evapRate" min="0.1" max="3" step="0.1" value="1">
                </div>
                
                <div class="control-group">
                    <label>
                        Altitude Modifier
                        <span class="value-display" id="altModValue">1.0x</span>
                    </label>
                    <input type="range" id="altMod" min="0.5" max="2" step="0.1" value="1">
                </div>
                
                <div class="control-group">
                    <label>
                        Total Water
                        <span class="value-display" id="totalWaterValue">1000 units</span>
                    </label>
                    <input type="range" id="totalWater" min="500" max="2000" step="100" value="1000">
                </div>
            </div>
            
            <button class="reset-btn" id="resetBtn">Reset Simulation</button>
        </div>
        
        <div class="metrics">
            <div class="metrics-title">Water Distribution</div>
            <div class="metrics-container">
                <div class="metric">
                    <div class="metric-label">
                        <span>Cloud Water</span>
                        <span id="cloudWaterValue">0 units</span>
                    </div>
                    <div class="metric-bar-container">
                        <div class="metric-bar" id="cloudWaterBar" style="width: 0%; background-color: #ecf0f1;"></div>
                    </div>
                </div>
                
                <div class="metric">
                    <div class="metric-label">
                        <span>Rain Water</span>
                        <span id="rainWaterValue">0 units</span>
                    </div>
                    <div class="metric-bar-container">
                        <div class="metric-bar" id="rainWaterBar" style="width: 0%; background-color: #3498db;"></div>
                    </div>
                </div>
                
                <div class="metric">
                    <div class="metric-label">
                        <span>Pool Water</span>
                        <span id="poolWaterValue">0 units</span>
                    </div>
                    <div class="metric-bar-container">
                        <div class="metric-bar" id="poolWaterBar" style="width: 0%; background-color: #2980b9;"></div>
                    </div>
                </div>
                
                <div class="metric">
                    <div class="metric-label">
                        <span>Evaporating Water</span>
                        <span id="evapWaterValue">0 units</span>
                    </div>
                    <div class="metric-bar-container">
                        <div class="metric-bar" id="evapWaterBar" style="width: 0%; background-color: #bdc3c7;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Configuration
        const NUM_TERRAINS = 5;
        const CLOUD_PARTS = 5;
        const DAY_DURATION = 60000; // 60 seconds for a full day/night cycle
        const MAX_RAINDROPS = 100;
        const MAX_VAPORS = 200;
        const MAX_DOWNFLOWS = 50;
        
        // State variables
        let simulationState = {
            isDay: true,
            temperature: 25,
            dayTemperature: 25,
            nightTemperature: 15,
            evaporationRate: 1.0,
            altitudeModifier: 1.0,
            timeSpeed: 1.0,
            totalWater: 1000,
            time: 0,
            dayTime: 0,
            cloudWater: 500,
            rainWater: 0,
            poolWaters: Array(NUM_TERRAINS).fill(100),
            evaporatingWater: 0,
            raindrops: [],
            vapors: [],
            downflows: [],
            poolOverflows: Array(NUM_TERRAINS-1).fill(false)
        };
        
        // Elements
        const simulation = document.getElementById('simulation');
        const cloud = document.getElementById('cloud');
        const ground = document.getElementById('ground');
        const timeIndicator = document.getElementById('timeIndicator');
        const temperatureIndicator = document.getElementById('temperatureIndicator');
        const sunMoon = document.getElementById('sunMoon');
        
        // Control elements
        const timeSpeedSlider = document.getElementById('timeSpeed');
        const timeSpeedValue = document.getElementById('timeSpeedValue');
        const dayTempSlider = document.getElementById('dayTemp');
        const dayTempValue = document.getElementById('dayTempValue');
        const nightTempSlider = document.getElementById('nightTemp');
        const nightTempValue = document.getElementById('nightTempValue');
        const evapRateSlider = document.getElementById('evapRate');
        const evapRateValue = document.getElementById('evapRateValue');
        const altModSlider = document.getElementById('altMod');
        const altModValue = document.getElementById('altModValue');
        const totalWaterSlider = document.getElementById('totalWater');
        const totalWaterValue = document.getElementById('totalWaterValue');
        const resetBtn = document.getElementById('resetBtn');
        
        // Metrics elements
        const cloudWaterValue = document.getElementById('cloudWaterValue');
        const cloudWaterBar = document.getElementById('cloudWaterBar');
        const rainWaterValue = document.getElementById('rainWaterValue');
        const rainWaterBar = document.getElementById('rainWaterBar');
        const poolWaterValue = document.getElementById('poolWaterValue');
        const poolWaterBar = document.getElementById('poolWaterBar');
        const evapWaterValue = document.getElementById('evapWaterValue');
        const evapWaterBar = document.getElementById('evapWaterBar');
        
        // Create clouds
        function setupClouds() {
            cloud.innerHTML = '';
            const cloudWidth = 100 / CLOUD_PARTS;
            
            for (let i = 0; i < CLOUD_PARTS; i++) {
                const cloudPart = document.createElement('div');
                cloudPart.className = 'cloud-part';
                cloudPart.style.width = cloudWidth + '%';
                cloud.appendChild(cloudPart);
            }
        }
        
        // Create terrain
        function setupTerrain() {
            ground.innerHTML = '';
            const terrainWidth = 100 / NUM_TERRAINS;
            
            for (let i = 0; i < NUM_TERRAINS; i++) {
                const terrain = document.createElement('div');
                terrain.className = 'terrain';
                terrain.style.width = terrainWidth + '%';
                
                // Height increases from left to right
                const heightPercent = 15 + i * 10;
                terrain.style.height = heightPercent + '%';
                
                // Create water pool for each terrain
                const pool = document.createElement('div');
                pool.className = 'pool';
                pool.id = `pool-${i}`;
                pool.style.height = '0%';
                
                terrain.appendChild(pool);
                ground.appendChild(terrain);
            }
        }
        
        // Update cloud appearance based on water content
        function updateClouds() {
            const cloudParts = document.querySelectorAll('.cloud-part');
            const waterPerPart = simulationState.cloudWater / CLOUD_PARTS;
            const maxWaterPerPart = simulationState.totalWater / (CLOUD_PARTS * 2);
            
            cloudParts.forEach((part, index) => {
                const opacity = Math.min(0.8, 0.3 + (waterPerPart / maxWaterPerPart) * 0.5);
                part.style.backgroundColor = `rgba(255, 255, 255, ${opacity})`;
                
                // Make cloud parts bigger based on water content
                const baseHeight = 60;
                const extraHeight = Math.min(40, (waterPerPart / maxWaterPerPart) * 40);
                part.style.height = (baseHeight + extraHeight) + 'px';
                
                // Add some variation to cloud parts
                const variation = Math.sin(simulationState.time / 1000 + index) * 10;
                part.style.top = variation + 'px';
            });
        }
        
        // Update pools based on water content
        function updatePools() {
            for (let i = 0; i < NUM_TERRAINS; i++) {
                const pool = document.getElementById(`pool-${i}`);
                const terrain = pool.parentElement;
                const terrainHeight = parseInt(terrain.style.height);
                
                // Calculate how much of the pool is filled horizontally vs vertically
                const terrainWidth = terrain.offsetWidth;
                const maxHorizontalWater = terrainWidth * 10; // Arbitrary scaling factor
                
                let poolHeight;
                if (simulationState.poolWaters[i] <= maxHorizontalWater) {
                    // Water spreads horizontally first
                    const widthPercent = (simulationState.poolWaters[i] / maxHorizontalWater) * 100;
                    pool.style.width = Math.min(100, widthPercent) + '%';
                    poolHeight = '10%'; // Small fixed height while spreading horizontally
                } else {
                    // Then it grows vertically
                    pool.style.width = '100%'; // Full width
                    const extraWater = simulationState.poolWaters[i] - maxHorizontalWater;
                    const maxVerticalWater = terrainHeight * terrainWidth * 0.8; // Another scaling factor
                    const heightPercent = 10 + (extraWater / maxVerticalWater) * 90; // Start from 10%
                    poolHeight = Math.min(95, heightPercent) + '%'; // Cap at 95% to always see some terrain
                }
                
                pool.style.height = poolHeight;
                
                // Check for overflow
                if (i < NUM_TERRAINS - 1) { // Skip the last (lowest) terrain
                    const heightPercent = parseInt(poolHeight);
                    simulationState.poolOverflows[i] = heightPercent > 40; // Arbitrary threshold for overflow
                }
            }
        }
        
        // Create a raindrop
        function createRaindrop() {
            if (simulationState.raindrops.length >= MAX_RAINDROPS || simulationState.cloudWater <= 0) return;
            
            // Only create a raindrop if there's enough water in the cloud
            if (simulationState.cloudWater < 5) return;
            
            const cloudParts = document.querySelectorAll('.cloud-part');
            const randomPart = Math.floor(Math.random() * cloudParts.length);
            const cloudPart = cloudParts[randomPart];
            
            const waterAmount = 2 + Math.random() * 3; // 2-5 units of water
            if (simulationState.cloudWater >= waterAmount) {
                simulationState.cloudWater -= waterAmount;
                simulationState.rainWater += waterAmount;
                
                const raindrop = document.createElement('div');
                raindrop.className = 'raindrop';
                
                // Position the raindrop under a random position in the cloud
                const cloudRect = cloudPart.getBoundingClientRect();
                const simulationRect = simulation.getBoundingClientRect();
                
                const leftPos = cloudRect.left - simulationRect.left + Math.random() * cloudRect.width;
                raindrop.style.left = leftPos + 'px';
                raindrop.style.top = (cloudRect.bottom - simulationRect.top) + 'px';
                
                // Make raindrop size proportional to water amount
                raindrop.style.height = (waterAmount * 2 + 6) + 'px';
                raindrop.style.width = (waterAmount * 0.5 + 1.5) + 'px';
                
                // Store raindrop data
                const raindropData = {
                    element: raindrop,
                    x: leftPos,
                    y: cloudRect.bottom - simulationRect.top,
                    speed: 1 + Math.random() * 2,
                    waterAmount: waterAmount,
                    targetTerrain: Math.floor(leftPos / (simulationRect.width / NUM_TERRAINS))
                };
                
                simulationState.raindrops.push(raindropData);
                simulation.appendChild(raindrop);
            }
        }
        
        // Update raindrops
        function updateRaindrops() {
            for (let i = simulationState.raindrops.length - 1; i >= 0; i--) {
                const raindrop = simulationState.raindrops[i];
                raindrop.y += raindrop.speed * simulationState.timeSpeed * 5;
                raindrop.element.style.top = raindrop.y + 'px';
                
                // Check if raindrop has reached the ground or a pool
                const terrains = document.querySelectorAll('.terrain');
                const targetTerrain = terrains[raindrop.targetTerrain];
                const targetPool = targetTerrain.querySelector('.pool');
                
                const terrainRect = targetTerrain.getBoundingClientRect();
                const simulationRect = simulation.getBoundingClientRect();
                const terrainTop = terrainRect.top - simulationRect.top;
                
                if (raindrop.y >= terrainTop) {
                    // Add water to the pool
                    simulationState.poolWaters[raindrop.targetTerrain] += raindrop.waterAmount;
                    simulationState.rainWater -= raindrop.waterAmount;
                    
                    // Remove the raindrop
                    simulation.removeChild(raindrop.element);
                    simulationState.raindrops.splice(i, 1);
                }
            }
        }
        
        // Create water vapor (evaporation)
        function createVapor(terrainIndex) {
            if (simulationState.vapors.length >= MAX_VAPORS) return;
            
            // Check temperature conditions for evaporation
            if (simulationState.temperature < 10) return; // Too cold to evaporate
            
            // Calculate evaporation rate based on temperature and altitude
            const baseEvapRate = Math.max(0, (simulationState.temperature - 10) / 30);
            const altitudeFactor = 1 - (terrainIndex * simulationState.altitudeModifier * 0.1);
            const evapRate = baseEvapRate * simulationState.evaporationRate * altitudeFactor;
            
            // Only create vapor if there's water in the pool
            if (simulationState.poolWaters[terrainIndex] < 1) return;
            
            // Probability check for vapor creation
            if (Math.random() > evapRate * 0.1) return;
            
            const waterAmount = 0.2 + Math.random() * 0.3; // Small amount of water evaporates
            if (simulationState.poolWaters[terrainIndex] >= waterAmount) {
                simulationState.poolWaters[terrainIndex] -= waterAmount;
                simulationState.evaporatingWater += waterAmount;
                
                // Get pool position
                const pool = document.getElementById(`pool-${terrainIndex}`);
                const poolRect = pool.getBoundingClientRect();
                const simulationRect = simulation.getBoundingClientRect();
                
                const vapor = document.createElement('div');
                vapor.className = 'vapor';
                
                // Position vapor above the pool
                const leftPos = poolRect.left - simulationRect.left + Math.random() * poolRect.width;
                const topPos = poolRect.top - simulationRect.top - Math.random() * 10;
                
                vapor.style.left = leftPos + 'px';
                vapor.style.top = topPos + 'px';
                
                // Store vapor data
                const vaporData = {
                    element: vapor,
                    x: leftPos,
                    y: topPos,
                    speed: 0.5 + Math.random() * 1,
                    waterAmount: waterAmount,
                    age: 0,
                    maxAge: 100 + Math.random() * 100
                };
                
                simulationState.vapors.push(vaporData);
                simulation.appendChild(vapor);
            }
        }
        
        // Update water vapor
        function updateVapors() {
            for (let i = simulationState.vapors.length - 1; i >= 0; i--) {
                const vapor = simulationState.vapors[i];
                
                // Vapors rise and move slightly sideways
                vapor.y -= vapor.speed * simulationState.timeSpeed;
                vapor.x += (Math.sin(vapor.age / 10) * 0.5) * simulationState.timeSpeed;
                vapor.age += simulationState.timeSpeed;
                
                vapor.element.style.top = vapor.y + 'px';
                vapor.element.style.left = vapor.x + 'px';
                
                // Check if vapor has reached the cloud or has lived its full life
                const cloudRect = cloud.getBoundingClientRect();
                const simulationRect = simulation.getBoundingClientRect();
                const cloudBottom = cloudRect.bottom - simulationRect.top;
                
                if (vapor.y <= cloudBottom || vapor.age >= vapor.maxAge) {
                    // Add water to the cloud
                    simulationState.cloudWater += vapor.waterAmount;
                    simulationState.evaporatingWater -= vapor.waterAmount;
                    
                    // Remove the vapor
                    simulation.removeChild(vapor.element);
                    simulationState.vapors.splice(i, 1);
                }
            }
        }
        
        // Create downflow (water running downhill)
        function createDownflow(fromTerrain) {
            if (simulationState.downflows.length >= MAX_DOWNFLOWS) return;
            
            // Only create downflow if there's overflow
            if (!simulationState.poolOverflows[fromTerrain]) return;
            
            const waterAmount = 1 + Math.random() * 2; // 1-3 units of water
            if (simulationState.poolWaters[fromTerrain] >= waterAmount) {
                simulationState.poolWaters[fromTerrain] -= waterAmount;
                simulationState.poolWaters[fromTerrain + 1] += waterAmount;
                
                // Get pool positions
                const fromPool = document.getElementById(`pool-${fromTerrain}`);
                const toPool = document.getElementById(`pool-${fromTerrain + 1}`);
                const fromRect = fromPool.getBoundingClientRect();
                const toRect = toPool.getBoundingClientRect();
                const simulationRect = simulation.getBoundingClientRect();
                
                const downflow = document.createElement('div');
                downflow.className = 'downflow';
                
                // Position at the bottom edge of the upper pool
                const leftPos = fromRect.right - simulationRect.left;
                const topPos = fromRect.bottom - simulationRect.top - 5;
                
                downflow.style.left = leftPos + 'px';
                downflow.style.top = topPos + 'px';
                
                // Size proportional to water amount
                downflow.style.width = (waterAmount * 1.5 + 3) + 'px';
                downflow.style.height = (waterAmount * 1.5 + 3) + 'px';
                
                // Store downflow data
                const downflowData = {
                    element: downflow,
                    x: leftPos,
                    y: topPos,
                    targetX: toRect.left - simulationRect.left + 10,
                    targetY: toRect.top - simulationRect.top,
                    progress: 0,
                    speed: 0.02 + Math.random() * 0.02
                };
                
                simulationState.downflows.push(downflowData);
                simulation.appendChild(downflow);
            }
        }
        
        // Update downflows
        function updateDownflows() {
            for (let i = simulationState.downflows.length - 1; i >= 0; i--) {
                const downflow = simulationState.downflows[i];
                
                downflow.progress += downflow.speed * simulationState.timeSpeed;
                
                // Use cubic bezier-like curve for realistic water flow
                const t = downflow.progress;
                const newX = downflow.x + (downflow.targetX - downflow.x) * t;
                
                // Add a slight arc to the path
                const midY = downflow.y + (downflow.targetY - downflow.y) * 0.5 + 20;
                const newY = downflow.y * (1 - t) * (1 - t) + midY * 2 * t * (1 - t) + downflow.targetY * t * t;
                
                downflow.element.style.left = newX + 'px';
                downflow.element.style.top = newY + 'px';
                
                // Remove when reaching the target
                if (downflow.progress >= 1) {
                    simulation.removeChild(downflow.element);
                    simulationState.downflows.splice(i, 1);
                }
            }
        }
        
        // Update metrics display
        function updateMetrics() {
            const totalWater = simulationState.cloudWater + simulationState.rainWater + 
                              simulationState.poolWaters.reduce((a, b) => a + b, 0) + 
                              simulationState.evaporatingWater;
            
            // Update text displays
            cloudWaterValue.textContent = Math.round(simulationState.cloudWater) + ' units';
            rainWaterValue.textContent = Math.round(simulationState.rainWater) + ' units';
            poolWaterValue.textContent = Math.round(simulationState.poolWaters.reduce((a, b) => a + b, 0)) + ' units';
            evapWaterValue.textContent = Math.round(simulationState.evaporatingWater) + ' units';
            
            // Update progress bars
            cloudWaterBar.style.width = (simulationState.cloudWater / totalWater * 100) + '%';
            rainWaterBar.style.width = (simulationState.rainWater / totalWater * 100) + '%';
            poolWaterBar.style.width = (simulationState.poolWaters.reduce((a, b) => a + b, 0) / totalWater * 100) + '%';
            evapWaterBar.style.width = (simulationState.evaporatingWater / totalWater * 100) + '%';
        }
        
        // Update day/night cycle
        function updateDayNightCycle() {
            // Update day/night state
            simulationState.dayTime += simulationState.timeSpeed;
            const dayProgress = (simulationState.dayTime % DAY_DURATION) / DAY_DURATION;
            
            // Day is from 0.25 to 0.75 of the cycle (to center the sun/moon)
            simulationState.isDay = dayProgress >= 0.25 && dayProgress < 0.75;
            
            // Update sky background
            if (simulationState.isDay) {
                const progress = (dayProgress - 0.25) / 0.5; // 0 to 1 during day
                const brightness = 0.7 + Math.sin(progress * Math.PI) * 0.3; // Brightest at noon
                simulation.style.background = `linear-gradient(to bottom, 
                    rgba(135, 206, 235, ${brightness}), 
                    rgba(70, 130, 180, ${brightness * 0.8}))`;
            } else {
                let progress;
                if (dayProgress < 0.25) {
                    progress = dayProgress / 0.25; // Dawn approaching
                } else {
                    progress = (dayProgress - 0.75) / 0.25; // Dusk passing
                }
                simulation.style.background = `linear-gradient(to bottom, 
                    rgba(25, 25, 112, ${0.9 - progress * 0.3}), 
                    rgba(0, 0, 50, ${0.9 - progress * 0.3}))`;
            }
            
            // Update temperature based on day/night
            if (simulationState.isDay) {
                const dayProgress = (simulationState.dayTime % (DAY_DURATION / 2)) / (DAY_DURATION / 2);
                simulationState.temperature = simulationState.nightTemperature + 
                                            (simulationState.dayTemperature - simulationState.nightTemperature) * 
                                            Math.sin(dayProgress * Math.PI);
            } else {
                simulationState.temperature = simulationState.nightTemperature;
            }
            
            // Update sun/moon position
            const cycleProgress = (simulationState.dayTime % DAY_DURATION) / DAY_DURATION;
            const angle = cycleProgress * 2 * Math.PI;
            
            const radius = simulation.offsetHeight * 0.4;
            const centerX = simulation.offsetWidth * 0.5;
            const centerY = simulation.offsetHeight * 0.3;
            
            const x = centerX + Math.cos(angle - Math.PI/2) * radius;
            const y = centerY + Math.sin(angle - Math.PI/2) * radius;
            
            sunMoon.style.left = x + 'px';
            sunMoon.style.top = y + 'px';
            
            // Update sun/moon appearance
            if (simulationState.isDay) {
                sunMoon.style.backgroundColor = '#FFDB58';
                sunMoon.style.boxShadow = '0 0 20px rgba(255, 219, 88, 0.8)';
            } else {
                sunMoon.style.backgroundColor = '#F5F3CE';
                sunMoon.style.boxShadow = '0 0 10px rgba(245, 243, 206, 0.5)';
            }
            
            // Update indicators
            timeIndicator.textContent = simulationState.isDay ? 'Day' : 'Night';
            temperatureIndicator.textContent = Math.round(simulationState.temperature) + '°C';
        }
        
        // Main update function
        function update() {
            simulationState.time += 16 * simulationState.timeSpeed; // 16ms is roughly 60fps
            
            // Update day/night cycle
            updateDayNightCycle();
            
            // Balance water in the system
            balanceWaterSystem();
            
            // Create raindrops (both day and night)
            if (Math.random() < 0.2 * simulationState.timeSpeed) {
                createRaindrop();
            }
            
            // Create vapors (based on temperature)
            for (let i = 0; i < NUM_TERRAINS; i++) {
                if (simulationState.temperature >= 10) { // Only evaporate when warm enough
                    createVapor(i);
                }
            }
            
            // Create downflows for each terrain that has overflow
            for (let i = 0; i < NUM_TERRAINS - 1; i++) {
                if (simulationState.poolOverflows[i] && Math.random() < 0.2 * simulationState.timeSpeed) {
                    createDownflow(i);
                }
            }
            
            // Update existing elements
            updateClouds();
            updatePools();
            updateRaindrops();
            updateVapors();
            updateDownflows();
            updateMetrics();
            
            requestAnimationFrame(update);
        }
        
        // Ensure total water in system is conserved
        function balanceWaterSystem() {
            const totalWaterInSystem = simulationState.cloudWater + 
                                     simulationState.rainWater + 
                                     simulationState.poolWaters.reduce((a, b) => a + b, 0) + 
                                     simulationState.evaporatingWater;
            
            // If there's a significant discrepancy, adjust cloud water
            if (Math.abs(totalWaterInSystem - simulationState.totalWater) > 1) {
                const adjustment = simulationState.totalWater - totalWaterInSystem;
                simulationState.cloudWater += adjustment;
            }
        }
        
        // Initialize the simulation
        function initSimulation() {
            // Reset state
            simulationState = {
                isDay: true,
                temperature: parseInt(dayTempSlider.value),
                dayTemperature: parseInt(dayTempSlider.value),
                nightTemperature: parseInt(nightTempSlider.value),
                evaporationRate: parseFloat(evapRateSlider.value),
                altitudeModifier: parseFloat(altModSlider.value),
                timeSpeed: parseFloat(timeSpeedSlider.value),
                totalWater: parseInt(totalWaterSlider.value),
                time: 0,
                dayTime: DAY_DURATION * 0.25, // Start at beginning of day
                cloudWater: parseInt(totalWaterSlider.value) * 0.5,
                rainWater: 0,
                poolWaters: Array(NUM_TERRAINS).fill(parseInt(totalWaterSlider.value) * 0.1),
                evaporatingWater: 0,
                raindrops: [],
                vapors: [],
                downflows: [],
                poolOverflows: Array(NUM_TERRAINS-1).fill(false)
            };
            
            // Clear any existing elements
            document.querySelectorAll('.raindrop, .vapor, .downflow').forEach(el => {
                el.parentNode.removeChild(el);
            });
            
            // Setup UI
            setupClouds();
            setupTerrain();
            updateClouds();
            updatePools();
            updateMetrics();
        }
        
        // Set up event listeners
        timeSpeedSlider.addEventListener('input', () => {
            simulationState.timeSpeed = parseFloat(timeSpeedSlider.value);
            timeSpeedValue.textContent = simulationState.timeSpeed.toFixed(1) + 'x';
        });
        
        dayTempSlider.addEventListener('input', () => {
            simulationState.dayTemperature = parseInt(dayTempSlider.value);
            dayTempValue.textContent = simulationState.dayTemperature + '°C';
        });
        
        nightTempSlider.addEventListener('input', () => {
            simulationState.nightTemperature = parseInt(nightTempSlider.value);
            nightTempValue.textContent = simulationState.nightTemperature + '°C';
        });
        
        evapRateSlider.addEventListener('input', () => {
            simulationState.evaporationRate = parseFloat(evapRateSlider.value);
            evapRateValue.textContent = simulationState.evaporationRate.toFixed(1) + 'x';
        });
        
        altModSlider.addEventListener('input', () => {
            simulationState.altitudeModifier = parseFloat(altModSlider.value);
            altModValue.textContent = simulationState.altitudeModifier.toFixed(1) + 'x';
        });
        
        totalWaterSlider.addEventListener('input', () => {
            const newTotal = parseInt(totalWaterSlider.value);
            // Adjust the amount of water proportionally
            const ratio = newTotal / simulationState.totalWater;
            
            simulationState.cloudWater *= ratio;
            simulationState.rainWater *= ratio;
            simulationState.poolWaters = simulationState.poolWaters.map(w => w * ratio);
            simulationState.evaporatingWater *= ratio;
            
            simulationState.totalWater = newTotal;
            totalWaterValue.textContent = simulationState.totalWater + ' units';
        });
        
        resetBtn.addEventListener('click', initSimulation);
        
        // Start the simulation
        initSimulation();
        update();
    </script>
</body>
</html>