<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Last Stack Standing - Money Printer Simulation</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  padding: 20px;
  color: #333;
}

.container {
  max-width: 1400px;
  margin: 0 auto;
  background: white;
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.1);
  overflow: hidden;
}

.header {
  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
  color: white;
  padding: 30px;
  text-align: center;
  position: relative;
}



.header h1 {
  font-size: 2.5em;
  margin-bottom: 10px;
  font-weight: 300;
}

.header p {
  font-size: 1.2em;
  opacity: 0.9;
}

.main-content {
  display: grid;
  grid-template-columns: 350px 1fr;
  gap: 0;
  min-height: 800px;
}

.controls-panel {
  background: #f8f9fa;
  padding: 30px;
  border-right: 1px solid #e9ecef;
}

.control-group {
  margin-bottom: 25px;
}

.control-group h3 {
  margin-bottom: 15px;
  color: #2c3e50;
  display: flex;
  align-items: center;
  gap: 10px;
}

.info-icon {
  width: 20px;
  height: 20px;
  background: #3498db;
  border-radius: 50%;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  cursor: help;
  position: relative;
}

.info-icon:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  background: #2c3e50;
  color: white;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 11px;
  white-space: nowrap;
  bottom: 125%;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.mode-selector {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.mode-selector.horizontal {
  flex-direction: row;
  gap: 15px;
}

.controls-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
}

.controls-row.three-col {
  grid-template-columns: 2fr 1fr 1fr;
  gap: 20px;
  align-items: start;
}

.mode-option {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 15px;
  border: 2px solid #e9ecef;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.mode-option:hover {
  border-color: #3498db;
  background: #f0f8ff;
}

.mode-option.active {
  border-color: #3498db;
  background: #e8f4fd;
}

.mode-option input[type="radio"] {
  margin: 0;
}

.mode-info {
  flex: 1;
}

.mode-title {
  font-weight: 600;
  color: #2c3e50;
}

.mode-desc {
  font-size: 0.9em;
  color: #7f8c8d;
  margin-top: 5px;
}

.input-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

label {
  font-weight: 600;
  color: #2c3e50;
}

input[type="number"], input[type="range"] {
  padding: 12px;
  border: 2px solid #e9ecef;
  border-radius: 8px;
  font-size: 16px;
  transition: border-color 0.3s ease;
}

input[type="number"]:focus, input[type="range"]:focus {
  outline: none;
  border-color: #3498db;
}

.range-value {
  text-align: center;
  font-weight: 600;
  color: #3498db;
  font-size: 1.1em;
}

.button-group {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.control-buttons {
  display: flex;
  gap: 15px;
  margin-bottom: 25px;
  justify-content: center;
}

button {
  padding: 15px 25px;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.btn-primary {
  background: linear-gradient(135deg, #3498db, #2980b9);
  color: white;
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);
}

.btn-secondary {
  background: #95a5a6;
  color: white;
}

.btn-secondary:hover {
  background: #7f8c8d;
  transform: translateY(-2px);
}

.btn-danger {
  background: #e74c3c;
  color: white;
}

.btn-danger:hover {
  background: #c0392b;
  transform: translateY(-2px);
}

.visualization-panel {
  padding: 30px;
  background: white;
}

.viz-header {
  display: flex;
  justify-content: between;
  align-items: center;
  margin-bottom: 25px;
}

.status-info {
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.status-item {
  background: #f8f9fa;
  padding: 15px 20px;
  border-radius: 10px;
  text-align: center;
  border-left: 4px solid #3498db;
}

.status-value {
  font-size: 1.5em;
  font-weight: 700;
  color: #2c3e50;
}

.status-label {
  font-size: 0.9em;
  color: #7f8c8d;
  margin-top: 5px;
}

.charts-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 30px;
  margin-top: 25px;
}

.chart {
  background: #f8f9fa;
  border-radius: 15px;
  padding: 25px;
  border: 1px solid #e9ecef;
}

.chart h3 {
  margin-bottom: 20px;
  color: #2c3e50;
  text-align: center;
}

.chart-content {
  height: 300px;
  display: flex;
  align-items: end;
  justify-content: space-around;
  gap: 5px;
  border-bottom: 2px solid #dee2e6;
  border-left: 2px solid #dee2e6;
  padding: 10px;
  position: relative;
}

.bar {
  background: linear-gradient(135deg, #3498db, #2980b9);
  border-radius: 4px 4px 0 0;
  min-width: 25px;
  transition: all 0.3s ease;
  position: relative;
  display: flex;
  flex-direction: column;
  justify-content: end;
}

.bar:hover {
  background: linear-gradient(135deg, #e74c3c, #c0392b);
  transform: scale(1.05);
}

.bar-value {
  position: absolute;
  top: -25px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 11px;
  font-weight: 600;
  color: #2c3e50;
}

.bar-label {
  position: absolute;
  bottom: -20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
  color: #7f8c8d;
}

.money-printer-indicator {
  background: linear-gradient(135deg, #f1c40f, #f39c12);
  color: #2c3e50;
  padding: 10px 20px;
  border-radius: 25px;
  font-weight: 600;
  display: inline-block;
  margin-bottom: 15px;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

.educational-note {
  background: #e8f4fd;
  border: 1px solid #3498db;
  border-radius: 10px;
  padding: 20px;
  margin-top: 25px;
}

.educational-note h4 {
  color: #2c3e50;
  margin-bottom: 10px;
}

.educational-note p {
  color: #34495e;
  line-height: 1.6;
}

.running {
  opacity: 0.7;
  pointer-events: none;
}

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
}

.modal-overlay.active {
  opacity: 1;
  visibility: visible;
}

@media (max-width: 1200px) {
  .main-content {
      grid-template-columns: 1fr;
  }
  
  .charts-container {
      grid-template-columns: 1fr;
  }

  .modal {
      margin: 10px;
      padding: 20px;
  }
}

.modal {
  background: white;
  border-radius: 20px;
  padding: 30px;
  max-width: 700px;
  max-height: 80vh;
  overflow-y: auto;
  margin: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  transform: scale(0.9);
  transition: all 0.3s ease;
}

.modal-overlay.active .modal {
  transform: scale(1);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 25px;
  padding-bottom: 15px;
  border-bottom: 2px solid #e9ecef;
}

.modal-title {
  font-size: 1.8em;
  color: #2c3e50;
  margin: 0;
}

.close-button {
  background: none;
  border: none;
  font-size: 24px;
  color: #7f8c8d;
  cursor: pointer;
  padding: 5px;
  border-radius: 50%;
  width: 35px;
  height: 35px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.close-button:hover {
  background: #f8f9fa;
  color: #2c3e50;
}

.modal-content {
  line-height: 1.6;
  color: #34495e;
}

.modal-section {
  margin-bottom: 25px;
}

.modal-section h3 {
  color: #2c3e50;
  margin-bottom: 12px;
  font-size: 1.3em;
}

.modal-section h4 {
  color: #34495e;
  margin-bottom: 10px;
  margin-top: 15px;
  font-size: 1.1em;
}

.modal-section p, .modal-section li {
  margin-bottom: 8px;
}

.modal-section ul {
  padding-left: 20px;
}

.highlight-box {
  background: #e8f4fd;
  border: 1px solid #3498db;
  border-radius: 8px;
  padding: 15px;
  margin: 15px 0;
}

.highlight-box h4 {
  color: #2980b9;
  margin-top: 0;
}

.tab-navigation {
  display: flex;
  background: #f8f9fa;
  border-bottom: 1px solid #e9ecef;
  margin: 0;
}

.tab-button {
  background: none;
  border: none;
  padding: 15px 30px;
  font-size: 16px;
  font-weight: 600;
  color: #7f8c8d;
  cursor: pointer;
  border-bottom: 3px solid transparent;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.tab-button:hover {
  color: #2c3e50;
  background: #ecf0f1;
}

.tab-button.active {
  color: #3498db;
  border-bottom-color: #3498db;
  background: white;
}

.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}

.science-container {
  padding: 30px;
  background: white;
  border-radius: 20px;
  margin: 20px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.1);
  max-width: calc(100% - 40px);
  box-sizing: border-box;
}

.science-header {
  text-align: center;
  margin-bottom: 30px;
}

.science-header h2 {
  color: #2c3e50;
  margin-bottom: 10px;
}

.science-header p {
  color: #7f8c8d;
  font-size: 1.1em;
}

.super-sim-controls {
  background: #f8f9fa;
  padding: 25px;
  border-radius: 15px;
  margin-bottom: 30px;
  border: 1px solid #e9ecef;
}

.progress-section {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-bottom: 25px;
}

.progress-item {
  background: white;
  padding: 20px;
  border-radius: 10px;
  border: 1px solid #e9ecef;
  text-align: center;
}

.progress-value {
  font-size: 1.8em;
  font-weight: 700;
  color: #3498db;
  margin-bottom: 5px;
}

.progress-label {
  color: #7f8c8d;
  font-size: 0.9em;
}

.progress-bar-container {
  background: #ecf0f1;
  border-radius: 10px;
  height: 8px;
  margin: 15px 0;
  overflow: hidden;
}

.progress-bar {
  background: linear-gradient(135deg, #3498db, #2980b9);
  height: 100%;
  width: 0%;
  transition: width 0.3s ease;
}

.scatter-plot-container {
  background: white;
  border-radius: 15px;
  padding: 25px;
  border: 1px solid #e9ecef;
  height: 500px;
  max-width: 100%;
  box-sizing: border-box;
}

.scatter-plot {
  width: 100%;
  height: 100%;
  border: 1px solid #dee2e6;
  border-radius: 8px;
}
</style>
</head>
<body>
<div class="container">
<div class="header">
  <h1>🎲 Last Stack Standing</h1>
  <p>Economic Simulation: The Unfair Advantage of Money Creation</p>
</div>

<div class="tab-navigation">
  <button class="tab-button active" onclick="switchTab('sandbox')">🧪 Sandbox</button>
  <button class="tab-button" onclick="switchTab('science')">🔬 Science</button>
</div>

<div id="sandbox-tab" class="tab-content active">
<div class="main-content">
  <div class="controls-panel">
      <div class="control-group">
          <h3>
              Game Mode 
              <span class="info-icon" data-tooltip="Compare fair play vs. money printer advantage">ℹ</span>
          </h3>
          <div class="mode-selector">
              <div class="mode-option active" onclick="setMode('fair')">
                  <input type="radio" name="mode" value="fair" checked>
                  <div class="mode-info">
                      <div class="mode-title">Fair Play</div>
                      <div class="mode-desc">All players compete equally</div>
                  </div>
              </div>
              <div class="mode-option" onclick="setMode('printer')">
                  <input type="radio" name="mode" value="printer">
                  <div class="mode-info">
                      <div class="mode-title">Money Printer</div>
                      <div class="mode-desc">Player 1 has limited chip bailouts</div>
                  </div>
              </div>
          </div>
          
          <div class="printer-bailouts-control" id="printerControls" style="display: none;">
              <div class="input-group" style="margin-top: 15px;">
                  <label style="display: flex; align-items: center; gap: 10px;">
                      Printer Bailouts 
                      <span class="info-icon" data-tooltip="How many times Player 1 can get bailed out PER GAME when eliminated">ℹ</span>
                  </label>
                  <input type="range" id="printerBailouts" min="1" max="20" value="5" oninput="updatePrinterBailouts(this.value)">
                  <div class="range-value" id="printerBailoutsValue">5 Bailouts</div>
              </div>
              <div class="input-group" style="margin-top: 15px;">
                  <label style="display: flex; align-items: center; gap: 10px;">
                      Bailout Size 
                      <span class="info-icon" data-tooltip="Money printer bailout as % of total chips in play">ℹ</span>
                  </label>
                  <input type="range" id="bailoutPercentage" min="5" max="100" value="25" step="5" oninput="updateBailoutPercentage(this.value)">
                  <div class="range-value" id="bailoutPercentageValue">25% of Total Chips</div>
              </div>
          </div>
      </div>

      <div class="control-group">
          <h3>
              Players 
              <span class="info-icon" data-tooltip="More players = more realistic economic simulation">ℹ</span>
          </h3>
          <div class="input-group">
              <input type="range" id="playerCount" min="2" max="12" value="6" oninput="updatePlayerCount(this.value)">
              <div class="range-value" id="playerCountValue">6 Players</div>
          </div>
      </div>

      <div class="control-group">
          <h3>
              Simulations 
              <span class="info-icon" data-tooltip="More simulations = more accurate statistical results">ℹ</span>
          </h3>
          <div class="input-group">
              <input type="range" id="simCount" min="10" max="1000" value="100" step="10" oninput="updateSimCount(this.value)">
              <div class="range-value" id="simCountValue">100 Rounds</div>
          </div>
      </div>

      <div class="control-group">
          <h3>
              Visualization 
              <span class="info-icon" data-tooltip="Show real-time chip balance during each game (slower but more detailed)">ℹ</span>
          </h3>
          <div class="mode-option" onclick="toggleCurrentGameDisplay()" style="cursor: pointer;">
              <input type="checkbox" id="showCurrentGame" onchange="toggleCurrentGameDisplay()">
              <div class="mode-info">
                  <div class="mode-title">Show Current Game Progress</div>
                  <div class="mode-desc">Update chip chart every 50 rounds during gameplay</div>
              </div>
          </div>
      </div>

      <div class="control-group">
        <h3>
            Stakes Progression 
            <span class="info-icon" data-tooltip="How stakes increase: linear (1,2,3,4) or exponential (1,2,4,8)">ℹ</span>
        </h3>
        <div class="mode-selector horizontal">
            <div class="mode-option active" onclick="setStakesProgression('linear')">
                <input type="radio" name="stakes" value="linear" checked>
                <div class="mode-info">
                    <div class="mode-title">Linear (1,2,3,4...)</div>
                    <div class="mode-desc">Stakes increase by +1 each interval</div>
                </div>
            </div>
            <div class="mode-option" onclick="setStakesProgression('exponential')">
                <input type="radio" name="stakes" value="exponential">
                <div class="mode-info">
                    <div class="mode-title">Exponential (1,2,4,8...)</div>
                    <div class="mode-desc">Stakes double each interval</div>
                </div>
            </div>
        </div>
        
        <div class="input-group" style="margin-top: 15px;">
            <label style="display: flex; align-items: center; gap: 10px;">
                Stakes Interval 
                <span class="info-icon" data-tooltip="How often stakes increase (every X rounds)">ℹ</span>
            </label>
            <input type="range" id="stakesInterval" min="10" max="500" value="100" step="10" oninput="updateStakesInterval(this.value)">
            <div class="range-value" id="stakesIntervalValue">Every 100 Rounds</div>
        </div>
    </div>        





      <div class="educational-note">
          <h4>💡 What This Demonstrates</h4>
          <p>In fair play, wins are distributed randomly among all players. With a "money printer," Player 1 gets limited bailouts PER GAME, creating an unfair advantage - much like how those who can create money in real economies have advantages over others.</p>
      </div>
  </div>

  <div class="visualization-panel">
      <div class="control-buttons">
          <button class="btn-primary" onclick="runSimulation()">▶ Start Simulation</button>
          <button class="btn-secondary" onclick="pauseSimulation()">⏸ Pause</button>
          <button class="btn-danger" onclick="resetSimulation()">🔄 Reset</button>
          <button class="btn-secondary" onclick="openAboutModal()">📖 Learn More</button>
      </div>
      
      <div class="viz-header">
          <div class="status-info">
              <div class="status-item">
                  <div class="status-value" id="currentSim">0</div>
                  <div class="status-label">Current Simulation</div>
              </div>
              <div class="status-item">
                  <div class="status-value" id="totalSims">0</div>
                  <div class="status-label">Total Completed</div>
              </div>
              <div class="status-item">
                  <div class="status-value" id="currentWinner">-</div>
                  <div class="status-label">Leading Player</div>
              </div>
              <div class="status-item">
                  <div class="status-value" id="printerBailoutsUsed">-</div>
                  <div class="status-label">Bailouts Used</div>
              </div>
          </div>
      </div>

      <div id="moneyPrinterAlert" class="money-printer-indicator" style="display: none;">
          💰 Money Printer Active - Player 1 Gets 5 Bailouts When Eliminated
      </div>

      <div class="charts-container">
          <div class="chart">
              <h3>Current Game: Chip Balance</h3>
              <div class="chart-content" id="chipChart">
                  <div style="text-align: center; color: #7f8c8d; margin: auto;">
                      Click "Start Simulation" to begin
                  </div>
              </div>
          </div>

          <div class="chart">
              <h3>Total Wins Distribution</h3>
              <div class="chart-content" id="winsChart">
                  <div style="text-align: center; color: #7f8c8d; margin: auto;">
                      Results will appear here
                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
</div>

<!-- Science Tab -->
<div id="science-tab" class="tab-content">
<div class="science-container">
  <div class="science-header">
      <h2>🔬 Scientific Super Simulation</h2>
      <p>Comprehensive analysis of money printer advantage across 0-20 bailouts (420 total simulations)</p>
  </div>

  <div class="super-sim-controls">
      <div class="control-group" style="margin-bottom: 25px;">
          <div class="controls-row three-col">
              <div>
                  <h3 style="color: #2c3e50; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                      Stakes Progression 
                      <span class="info-icon" data-tooltip="How stakes increase: linear (1,2,3,4) or exponential (1,2,4,8)">ℹ</span>
                  </h3>
                  <div class="mode-selector horizontal">
                      <div class="mode-option active" onclick="setScienceStakesProgression('linear')">
                          <input type="radio" name="scienceStakes" value="linear" checked>
                          <div class="mode-info">
                              <div class="mode-title">Linear (1,2,3,4...)</div>
                              <div class="mode-desc">Stakes increase by +1 each interval</div>
                          </div>
                      </div>
                      <div class="mode-option" onclick="setScienceStakesProgression('exponential')">
                          <input type="radio" name="scienceStakes" value="exponential">
                          <div class="mode-info">
                              <div class="mode-title">Exponential (1,2,4,8...)</div>
                              <div class="mode-desc">Stakes double each interval</div>
                          </div>
                      </div>
                  </div>
              </div>
              <div>
                  <h3 style="color: #2c3e50; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                      Players 
                      <span class="info-icon" data-tooltip="Number of players in scientific simulations">ℹ</span>
                  </h3>
                  <div class="input-group">
                      <input type="range" id="sciencePlayerCount" min="2" max="12" value="6" oninput="updateSciencePlayerCount(this.value)">
                      <div class="range-value" id="sciencePlayerCountValue">6 Players</div>
                  </div>
              </div>
              <div>
                  <h3 style="color: #2c3e50; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                      Simulations 
                      <span class="info-icon" data-tooltip="Simulations per bailout amount (uses Sandbox setting)">ℹ</span>
                  </h3>
                  <div class="input-group">
                      <div class="range-value" id="scienceSimCountDisplay" style="color: #7f8c8d; font-size: 0.9em;">100 Rounds</div>
                      <div style="font-size: 0.8em; color: #95a5a6;">From Sandbox tab</div>
                  </div>
              </div>
          </div>
          
          <div class="controls-row" style="margin-top: 15px;">
              <div>
                  <h3 style="color: #2c3e50; margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
                      Stakes Interval 
                      <span class="info-icon" data-tooltip="How often stakes increase (every X rounds)">ℹ</span>
                  </h3>
                  <div class="input-group">
                      <input type="range" id="scienceStakesInterval" min="10" max="500" value="100" step="10" oninput="updateScienceStakesInterval(this.value)">
                      <div class="range-value" id="scienceStakesIntervalValue">Every 100 Rounds</div>
                  </div>
              </div>
              <div>
                  <h3 style="color: #2c3e50; margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
                      Bailout Size 
                      <span class="info-icon" data-tooltip="Money printer bailout as % of total chips in play">ℹ</span>
                  </h3>
                  <div class="input-group">
                      <input type="range" id="scienceBailoutPercentage" min="5" max="100" value="25" step="5" oninput="updateScienceBailoutPercentage(this.value)">
                      <div class="range-value" id="scienceBailoutPercentageValue">25% of Total Chips</div>
                  </div>
              </div>
          </div>
      </div>

      <div class="progress-section">
          <div class="progress-item">
              <div class="progress-value" id="currentBailouts">0</div>
              <div class="progress-label">Current Bailouts</div>
          </div>
          <div class="progress-item">
              <div class="progress-value" id="currentSimInSet">0/20</div>
              <div class="progress-label">Simulation in Set</div>
          </div>
      </div>
      
      <div class="progress-bar-container">
          <div class="progress-bar" id="overallProgress"></div>
      </div>
      <div style="text-align: center; color: #7f8c8d; font-size: 0.9em; margin-top: 10px;">
          <span id="overallProgressText">Ready to start - 0/420 simulations complete</span>
      </div>

      <div style="text-align: center; margin-top: 20px;">
          <button class="btn-primary" onclick="startSuperSimulation()" id="superSimButton">▶ Start Super Simulation</button>
          <button class="btn-secondary" onclick="pauseSuperSimulation()" id="superPauseButton">⏸ Pause</button>
          <button class="btn-danger" onclick="resetSuperSimulation()">🔄 Reset</button>
      </div>
  </div>

  <div class="scatter-plot-container">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="color: #2c3e50; margin: 0;">Player 1 Win Percentage vs. Money Printer Bailouts</h3>
          <div style="display: flex; gap: 15px; font-size: 12px;">
              <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                  <input type="checkbox" onchange="toggleWealthOverlay('inequalityRatio')" style="margin: 0;">
                  <span>Inequality Ratio</span>
              </label>
              <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                  <input type="checkbox" onchange="toggleWealthOverlay('economyShare')" style="margin: 0;">
                  <span>Economy Share %</span>
              </label>
              <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                  <input type="checkbox" onchange="toggleWealthOverlay('avgPoverty')" style="margin: 0;">
                  <span>Avg Other Player Wealth</span>
              </label>
              <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                  <input type="checkbox" onchange="toggleWealthOverlay('totalAccumulated')" style="margin: 0;">
                  <span>Player 1 Total Wealth</span>
              </label>
          </div>
      </div>
      <canvas class="scatter-plot" id="scatterPlot"></canvas>
  </div>

  <div class="scatter-plot-container" style="margin-top: 30px;">
      <h3 style="margin-bottom: 20px; color: #2c3e50; text-align: center;">Economic Impact Analysis</h3>
      <p style="text-align: center; color: #7f8c8d; font-size: 0.9em; margin-bottom: 15px;">
          Multi-metric view of how money printer bailouts affect key economic indicators
      </p>
      <canvas class="scatter-plot" id="economicChart"></canvas>
  </div>
</div>
</div>
</div>

<!-- About Modal -->
<div class="modal-overlay" id="aboutModal" onclick="closeAboutModal(event)">
<div class="modal" onclick="event.stopPropagation()">
  <div class="modal-header">
      <h2 class="modal-title">About This Simulation</h2>
      <button class="close-button" onclick="closeAboutModal()">×</button>
  </div>
  <div class="modal-content">
      <div class="modal-section">
          <h3>🎯 Purpose</h3>
          <p>This simulation demonstrates how the ability to create money (or resources) from nothing provides an unfair systemic advantage in competitive environments. It serves as an educational tool to illustrate economic inequality through a simple, understandable game.</p>
      </div>

      <div class="modal-section">
          <h3>🎮 Game Mechanics</h3>
          <h4>Basic Rules:</h4>
          <ul>
              <li>Each player starts with 10 chips</li>
              <li>Every round, all active players roll a 6-sided die</li>
              <li>The highest roller wins and takes chips from all other players</li>
              <li>Players are eliminated when they reach 0 chips</li>
              <li>Game ends when only one player remains</li>
          </ul>
          
          <h4>Escalating Stakes:</h4>
          <ul>
              <li><strong>Linear Mode:</strong> Rounds 1-99: 1 chip, 100-199: 2 chips, 200-299: 3 chips, etc.</li>
              <li><strong>Exponential Mode:</strong> Rounds 1-99: 1 chip, 100-199: 2 chips, 200-299: 4 chips, 300-399: 8 chips, etc.</li>
              <li>Stakes represent how many chips the winner takes from each loser per round</li>
          </ul>
      </div>

      <div class="modal-section">
          <h3>💰 Money Printer Mode</h3>
          <p>When enabled, Player 1 receives special privileges that simulate the ability to create money:</p>
          <ul>
              <li><strong>Bailout Mechanism:</strong> When Player 1 reaches 0 chips, they automatically receive 10 chips</li>
              <li><strong>Limited Usage:</strong> Number of bailouts is configurable (1-20 per game)</li>
              <li><strong>Per-Game Reset:</strong> Bailout count resets for each new game in the simulation</li>
              <li><strong>Eventually Limited:</strong> Once bailouts are exhausted, Player 1 plays by normal rules</li>
          </ul>
      </div>

      <div class="highlight-box">
          <h4>🔍 What to Observe</h4>
          <p><strong>Fair Play Mode:</strong> Wins should be distributed roughly equally among all players (~16.7% each with 6 players).</p>
          <p><strong>Money Printer Mode:</strong> Player 1 should win significantly more often, with the advantage scaling based on the number of bailouts allowed.</p>
      </div>

      <div class="modal-section">
          <h3>⚙️ Settings Explained</h3>
          <h4>Player Count (2-12):</h4>
          <p>More players make the simulation more realistic and dilute individual win percentages in fair play mode.</p>
          
          <h4>Simulation Count (10-1000):</h4>
          <p>Higher numbers provide more statistically significant results. 100+ simulations recommended for clear patterns.</p>
          
          <h4>Stakes Progression (Linear vs Exponential):</h4>
          <p>Controls how aggressively stakes increase to prevent infinite games when money printer mode creates stalemates.</p>
          
          <h4>Printer Bailouts (1-20):</h4>
          <p>Controls the power of the money printer. More bailouts = greater unfair advantage for Player 1.</p>
      </div>

      <div class="modal-section">
          <h3>🌍 Real-World Parallels</h3>
          <p>This simulation mirrors several real-world economic phenomena:</p>
          <ul>
              <li><strong>Central Banking:</strong> Ability to create money supply</li>
              <li><strong>Quantitative Easing:</strong> Creating money to bailout preferred entities</li>
              <li><strong>Fiat Currency Systems:</strong> Unlimited money creation by authorities</li>
              <li><strong>Corporate Bailouts:</strong> "Too big to fail" rescue mechanisms</li>
              <li><strong>Credit Creation:</strong> Banks creating money through lending</li>
          </ul>
      </div>

      <div class="modal-section">
          <h3>📊 Technical Implementation</h3>
          <h4>Randomness:</h4>
          <p>Uses JavaScript's Math.random() for dice rolls, ensuring fair probability distribution.</p>
          
          <h4>Timeout Prevention:</h4>
          <p>Escalating stakes prevent infinite games when money printer mode creates stalemates.</p>
          
          <h4>Data Aggregation:</h4>
          <p>Win counts accumulate across all completed simulations to show statistical patterns.</p>
      </div>

      <div class="highlight-box">
          <h4>💡 Educational Takeaway</h4>
          <p>Even in a completely fair game based purely on chance, the ability to create resources from nothing (money printing) provides a decisive systemic advantage. This illustrates how monetary policy and resource creation mechanisms can fundamentally alter competitive outcomes in real economies.</p>
      </div>
  </div>
</div>
</div>

<script>
let gameState = {
  mode: 'fair',
  playerCount: 6,
  simCount: 100,
  printerBailouts: 5,
  stakesProgression: 'linear', // 'linear' or 'exponential'
  stakesInterval: 100, // How often stakes increase (every X rounds)
  bailoutPercentage: 0.25, // Bailout size as percentage of total chips in play (1/4 = 25%)
  showCurrentGame: false, // Whether to show current game chip balance updates
  currentSim: 0,
  isRunning: false,
  isPaused: false,
  players: [],
  totalWins: [],
  totalChipsIssued: [], // Track total chips given to each player across all games
  totalChipsEndedWith: [], // Track total chips each player ended up with across all games
  currentGameBailoutsUsed: 0
};

let superSimState = {
  isRunning: false,
  isPaused: false,
  currentBailouts: 0,
  currentSimInSet: 0,
  totalSimulations: 0,
  stakesProgression: 'linear', // 'linear' or 'exponential' for science simulations
  stakesInterval: 100, // How often stakes increase (every X rounds) for science simulations
  bailoutPercentage: 0.25, // Bailout size as percentage of total chips in play for science simulations
  playerCount: 6, // Number of players for science simulations
  scatterData: [], // Array of {bailouts, winPercentage, wealthMetrics} objects
  wealthOverlays: {
    inequalityRatio: false,
    economyShare: false,
    avgPoverty: false,
    totalAccumulated: false
  },
  canvas: null,
  ctx: null,
  economicCanvas: null,
  economicCtx: null
};

function setMode(mode) {
  gameState.mode = mode;
  document.querySelectorAll('.mode-option').forEach(opt => opt.classList.remove('active'));
  event.target.closest('.mode-option').classList.add('active');
  document.querySelector(`input[value="${mode}"]`).checked = true;
  
  const alert = document.getElementById('moneyPrinterAlert');
  const printerControls = document.getElementById('printerControls');
  
  if (mode === 'printer') {
      alert.style.display = 'block';
      printerControls.style.display = 'block';
      updateMoneyPrinterAlert();
  } else {
      alert.style.display = 'none';
      printerControls.style.display = 'none';
  }
}

function setStakesProgression(progression) {
  gameState.stakesProgression = progression;
  document.querySelectorAll('input[name="stakes"]').forEach(input => {
      input.closest('.mode-option').classList.remove('active');
  });
  event.target.closest('.mode-option').classList.add('active');
  document.querySelector(`input[value="${progression}"]`).checked = true;
}

function updatePlayerCount(value) {
  gameState.playerCount = parseInt(value);
  document.getElementById('playerCountValue').textContent = `${value} Players`;
  
  // Only reset arrays if not running
  if (!gameState.isRunning && gameState.currentSim === 0) {
      gameState.totalWins = new Array(gameState.playerCount).fill(0);
      gameState.totalChipsIssued = new Array(gameState.playerCount).fill(0);
      gameState.totalChipsEndedWith = new Array(gameState.playerCount).fill(0);
      updateWinsChart();
      updateChipChart();
  }
}

function updateSimCount(value) {
  gameState.simCount = parseInt(value);
  document.getElementById('simCountValue').textContent = `${value} Rounds`;
  
  // Update Science tab display
  const scienceDisplay = document.getElementById('scienceSimCountDisplay');
  if (scienceDisplay) {
      scienceDisplay.textContent = `${value} Rounds`;
  }
}

function updatePrinterBailouts(value) {
  gameState.printerBailouts = parseInt(value);
  document.getElementById('printerBailoutsValue').textContent = `${value} Bailouts`;
  updateMoneyPrinterAlert();
}

function updateMoneyPrinterAlert() {
  const alert = document.getElementById('moneyPrinterAlert');
  if (gameState.mode === 'printer') {
      alert.innerHTML = `💰 Money Printer Active - Player 1 Gets ${gameState.printerBailouts} Bailouts Per Game When Eliminated`;
  }
}

function toggleCurrentGameDisplay() {
  const checkbox = document.getElementById('showCurrentGame');
  gameState.showCurrentGame = checkbox.checked;
}

function updateStakesInterval(value) {
  gameState.stakesInterval = parseInt(value);
  document.getElementById('stakesIntervalValue').textContent = `Every ${value} Rounds`;
}

function updateBailoutPercentage(value) {
  gameState.bailoutPercentage = parseInt(value) / 100;
  document.getElementById('bailoutPercentageValue').textContent = `${value}% of Total Chips`;
}

function updateScienceStakesInterval(value) {
  superSimState.stakesInterval = parseInt(value);
  document.getElementById('scienceStakesIntervalValue').textContent = `Every ${value} Rounds`;
}

function updateScienceBailoutPercentage(value) {
  superSimState.bailoutPercentage = parseInt(value) / 100;
  document.getElementById('scienceBailoutPercentageValue').textContent = `${value}% of Total Chips`;
}

function updateSciencePlayerCount(value) {
  superSimState.playerCount = parseInt(value);
  document.getElementById('sciencePlayerCountValue').textContent = `${value} Players`;
}

function toggleWealthOverlay(metric) {
  superSimState.wealthOverlays[metric] = !superSimState.wealthOverlays[metric];
  if (superSimState.canvas) {
      drawScatterPlot();
  }
}

function initializePlayers() {
  gameState.players = [];
  gameState.currentGameBailoutsUsed = 0; // Reset bailouts for each new game
  
  for (let i = 0; i < gameState.playerCount; i++) {
      gameState.players.push({
          id: i + 1,
          chips: 10,
          eliminated: false
      });
      // Track initial chips issued (10 chips to each player at start of each game)
      gameState.totalChipsIssued[i] += 10;
  }
}

function rollDie() {
  return Math.floor(Math.random() * 6) + 1;
}

function playRound(roundNumber) {
  const activePlayers = gameState.players.filter(p => !p.eliminated);
  if (activePlayers.length <= 1) return false;

  // Calculate stakes based on round number and progression type
  let stakesMultiplier;
  const intervalsPeriod = Math.floor(roundNumber / gameState.stakesInterval);
  
  if (gameState.stakesProgression === 'exponential') {
      // Exponential: 1, 2, 4, 8, 16, 32...
      stakesMultiplier = Math.pow(2, intervalsPeriod);
  } else {
      // Linear: 1, 2, 3, 4, 5, 6...
      stakesMultiplier = intervalsPeriod + 1;
  }

  // Roll dice for all active players
  const rolls = activePlayers.map(player => ({
      player: player,
      roll: rollDie()
  }));

  // Find the highest roll
  const maxRoll = Math.max(...rolls.map(r => r.roll));
  const winners = rolls.filter(r => r.roll === maxRoll);
  const winner = winners[Math.floor(Math.random() * winners.length)];

  // Winner takes chips from each other active player (escalating stakes)
  activePlayers.forEach(player => {
      if (player.id !== winner.player.id) {
          const chipsLost = Math.min(player.chips, stakesMultiplier);
          player.chips -= chipsLost;
          winner.player.chips += chipsLost;
      }
  });

  // Apply money printer if enabled and Player 1 is eliminated
  if (gameState.mode === 'printer' && 
      gameState.players[0].chips === 0 && 
      gameState.currentGameBailoutsUsed < gameState.printerBailouts) {
      
      // Calculate bailout amount as percentage of total chips in play
      const totalChipsInPlay = gameState.players.reduce((sum, player) => sum + player.chips, 0);
      const bailoutAmount = Math.max(1, Math.round(totalChipsInPlay * gameState.bailoutPercentage));
      
      // console.log(`DEBUG: Player 1 eliminated, using bailout ${gameState.currentGameBailoutsUsed + 1}/${gameState.printerBailouts} (Round ${roundNumber}, Stakes: ${stakesMultiplier}, Bailout: ${bailoutAmount})`);
      gameState.players[0].chips = bailoutAmount; // Bailout with calculated amount
      gameState.totalChipsIssued[0] += bailoutAmount; // Track chips issued to Player 1
      gameState.currentGameBailoutsUsed++;
      gameState.players[0].eliminated = false; // Make sure they're not eliminated
  }

  // Eliminate players with 0 chips
  gameState.players.forEach(player => {
      if (player.chips === 0) {
          // Don't eliminate Player 1 if they still have bailouts available
          if (!(gameState.mode === 'printer' && 
                player.id === 1 && 
                gameState.currentGameBailoutsUsed < gameState.printerBailouts)) {
              player.eliminated = true;
              if (player.id === 1 && gameState.mode === 'printer') {
                  // console.log(`DEBUG: Player 1 ELIMINATED - no more bailouts (used ${gameState.currentGameBailoutsUsed}/${gameState.printerBailouts})`);
              }
          }
      }
  });

  return true;
}

async function runSingleGame() {
  initializePlayers();
  // console.log(`DEBUG: Starting new game, Player 1 has ${gameState.printerBailouts} bailouts available`);
  
  let roundCount = 0;
  while (true) {
      roundCount++;
      if (!playRound(roundCount)) {
          break;
      }
      
      // Update chart every 50 rounds if we're running simulation and showing current game
      if (gameState.isRunning && gameState.showCurrentGame && roundCount % 50 === 0 && gameState.currentSim < gameState.simCount) {
          updateChipChart();
          // Add a small delay to make the visualization visible
          await new Promise(resolve => setTimeout(resolve, 50));
      }
      
      // Check if only one player remains
      const activePlayers = gameState.players.filter(p => !p.eliminated);
      if (activePlayers.length === 1) {
          const winnerId = activePlayers[0].id;
          // Record final chip counts for all players
          gameState.players.forEach((player, index) => {
              gameState.totalChipsEndedWith[index] += player.chips;
          });
          // console.log(`DEBUG: Game ended after ${roundCount} rounds, winner is Player ${winnerId}, Player 1 used ${gameState.currentGameBailoutsUsed} bailouts`);
          return winnerId;
      }
      
      // Safety check to prevent infinite loops
      if (roundCount > 1000) {
          const maxChips = Math.max(...gameState.players.map(p => p.chips));
          const winner = gameState.players.find(p => p.chips === maxChips);
          // Record final chip counts for all players
          gameState.players.forEach((player, index) => {
              gameState.totalChipsEndedWith[index] += player.chips;
          });
          // console.log(`DEBUG: Game timeout after 1000 rounds, winner by chips: Player ${winner ? winner.id : 'none'}`);
          return winner ? winner.id : null;
      }
  }
  return null;
}

function updateChipChart() {
  const chartContent = document.getElementById('chipChart');
  const chartTitle = chartContent.previousElementSibling;
  
  // Show different content based on simulation state
  if (gameState.currentSim >= gameState.simCount && gameState.currentSim > 0) {
      // Simulation completed - show total chips issued vs ended with
      chartTitle.textContent = 'Chip Summary by Player';
      
      // Remove existing legend if it exists
      const existingLegend = chartTitle.parentNode.querySelector('.chip-summary-legend');
      if (existingLegend) {
          existingLegend.remove();
      }
      
      // Add legend right after title
      const legend = document.createElement('div');
      legend.className = 'chip-summary-legend';
      legend.style.display = 'flex';
      legend.style.justifyContent = 'center';
      legend.style.gap = '15px';
      legend.style.marginTop = '5px';
      legend.style.marginBottom = '10px';
      legend.style.fontSize = '10px';
      
      const issuedLegend = document.createElement('div');
      issuedLegend.style.display = 'flex';
      issuedLegend.style.alignItems = 'center';
      issuedLegend.style.gap = '3px';
      issuedLegend.innerHTML = '<div style="width:8px;height:8px;background:linear-gradient(135deg, #85c1e9, #aed6f1);border-radius:1px;"></div>Issued';
      
      const gainsLegend = document.createElement('div');
      gainsLegend.style.display = 'flex';
      gainsLegend.style.alignItems = 'center';
      gainsLegend.style.gap = '3px';
      gainsLegend.innerHTML = '<div style="width:8px;height:8px;background:linear-gradient(135deg, #27ae60, #2ecc71);border-radius:1px;"></div>Gains';
      
      const lossesLegend = document.createElement('div');
      lossesLegend.style.display = 'flex';
      lossesLegend.style.alignItems = 'center';
      lossesLegend.style.gap = '3px';
      lossesLegend.innerHTML = '<div style="width:8px;height:8px;background:linear-gradient(135deg, #e74c3c, #c0392b);border-radius:1px;opacity:0.7;"></div>Losses';
      
      legend.appendChild(issuedLegend);
      legend.appendChild(gainsLegend);
      legend.appendChild(lossesLegend);
      chartTitle.parentNode.insertBefore(legend, chartContent);
      
      chartContent.innerHTML = '';

      const maxValue = Math.max(...gameState.totalChipsIssued, ...gameState.totalChipsEndedWith, 1);
      const chartHeight = 250;

      gameState.totalChipsIssued.forEach((issuedChips, index) => {
          const endedWithChips = gameState.totalChipsEndedWith[index];
          const netGain = endedWithChips - issuedChips;
          
          // Create container for the segmented bar
          const playerContainer = document.createElement('div');
          playerContainer.style.display = 'flex';
          playerContainer.style.flexDirection = 'column';
          playerContainer.style.alignItems = 'center';
          playerContainer.style.position = 'relative';
          playerContainer.style.height = `${chartHeight + 40}px`;
          playerContainer.style.justifyContent = 'flex-end';
          
          // Determine bar height (larger of the two values)
          const barValue = Math.max(issuedChips, endedWithChips);
          const barHeight = (barValue / maxValue) * chartHeight;
          
          // Create the main bar container
          const barContainer = document.createElement('div');
          barContainer.style.position = 'relative';
          barContainer.style.width = '30px';
          barContainer.style.height = `${barHeight}px`;
          barContainer.style.borderRadius = '4px 4px 0 0';
          barContainer.style.overflow = 'hidden';
          
          if (endedWithChips >= issuedChips) {
              // Player gained chips - show issued chips at bottom, gains at top
              
              // Bottom segment (issued chips)
              const issuedSegmentHeight = (issuedChips / barValue) * 100;
              const issuedSegment = document.createElement('div');
              issuedSegment.style.position = 'absolute';
              issuedSegment.style.bottom = '0';
              issuedSegment.style.width = '100%';
              issuedSegment.style.height = `${issuedSegmentHeight}%`;
              issuedSegment.style.background = gameState.mode === 'printer' && index === 0 
                  ? 'linear-gradient(135deg, #f4d03f, #f7dc6f)' 
                  : 'linear-gradient(135deg, #85c1e9, #aed6f1)';
              
              // Top segment (net gains)
              const gainSegmentHeight = 100 - issuedSegmentHeight;
              const gainSegment = document.createElement('div');
              gainSegment.style.position = 'absolute';
              gainSegment.style.top = '0';
              gainSegment.style.width = '100%';
              gainSegment.style.height = `${gainSegmentHeight}%`;
              gainSegment.style.background = gameState.mode === 'printer' && index === 0 
                  ? 'linear-gradient(135deg, #27ae60, #2ecc71)' 
                  : 'linear-gradient(135deg, #27ae60, #2ecc71)';
              
              barContainer.appendChild(issuedSegment);
              barContainer.appendChild(gainSegment);
          } else {
              // Player lost chips - show final total at bottom, losses as missing from top
              
              // Bottom segment (what they ended with)
              const endedSegmentHeight = (endedWithChips / barValue) * 100;
              const endedSegment = document.createElement('div');
              endedSegment.style.position = 'absolute';
              endedSegment.style.bottom = '0';
              endedSegment.style.width = '100%';
              endedSegment.style.height = `${endedSegmentHeight}%`;
              endedSegment.style.background = gameState.mode === 'printer' && index === 0 
                  ? 'linear-gradient(135deg, #f39c12, #e67e22)' 
                  : 'linear-gradient(135deg, #3498db, #2980b9)';
              
              // Top segment (losses - shown as faded/lost chips)
              const lossSegmentHeight = 100 - endedSegmentHeight;
              const lossSegment = document.createElement('div');
              lossSegment.style.position = 'absolute';
              lossSegment.style.top = '0';
              lossSegment.style.width = '100%';
              lossSegment.style.height = `${lossSegmentHeight}%`;
              lossSegment.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
              lossSegment.style.opacity = '0.7';
              
              barContainer.appendChild(endedSegment);
              barContainer.appendChild(lossSegment);
          }
          
          // Value display (moved to bottom)
          const valueDisplay = document.createElement('div');
          valueDisplay.style.position = 'absolute';
          valueDisplay.style.bottom = '-35px';
          valueDisplay.style.left = '50%';
          valueDisplay.style.transform = 'translateX(-50%)';
          valueDisplay.style.fontSize = '10px';
          valueDisplay.style.fontWeight = '600';
          valueDisplay.style.color = '#2c3e50';
          valueDisplay.style.textAlign = 'center';
          valueDisplay.style.whiteSpace = 'nowrap';
          valueDisplay.innerHTML = `${endedWithChips}<br/><span style="font-size: 8px; color: #7f8c8d;">(${netGain >= 0 ? '+' : ''}${netGain})</span>`;
          
          // Player label (moved lower to make room for value display)
          const label = document.createElement('div');
          label.className = 'bar-label';
          label.textContent = `P${index + 1}`;
          label.style.position = 'absolute';
          label.style.bottom = '-55px';
          label.style.left = '50%';
          label.style.transform = 'translateX(-50%)';

          playerContainer.appendChild(barContainer);
          playerContainer.appendChild(valueDisplay);
          playerContainer.appendChild(label);
          chartContent.appendChild(playerContainer);
      });
  } else {
      // Simulation running or not started - show current game chip balance
      chartTitle.textContent = 'Current Game: Chip Balance';
      chartContent.innerHTML = '';

      if (gameState.players.length === 0) {
          chartContent.innerHTML = '<div style="text-align: center; color: #7f8c8d; margin: auto;">Click "Start Simulation" to begin</div>';
          return;
      }

      const maxChips = Math.max(...gameState.players.map(p => p.chips), 1);
      const chartHeight = 250;

      gameState.players.forEach((player, index) => {
          const barHeight = (player.chips / maxChips) * chartHeight;
          const bar = document.createElement('div');
          bar.className = 'bar';
          bar.style.height = `${barHeight}px`;
          
          // Color coding
          if (player.eliminated) {
              bar.style.background = '#95a5a6';
          } else if (gameState.mode === 'printer' && index === 0) {
              bar.style.background = 'linear-gradient(135deg, #f39c12, #e67e22)';
          } else {
              bar.style.background = 'linear-gradient(135deg, #3498db, #2980b9)';
          }
          
          const value = document.createElement('div');
          value.className = 'bar-value';
          value.textContent = player.chips;
          bar.appendChild(value);

          const label = document.createElement('div');
          label.className = 'bar-label';
          label.textContent = `P${player.id}`;
          bar.appendChild(label);

          chartContent.appendChild(bar);
      });
  }
}

function updateWinsChart() {
  const chartContent = document.getElementById('winsChart');
  chartContent.innerHTML = '';

  if (gameState.currentSim === 0) {
      chartContent.innerHTML = '<div style="text-align: center; color: #7f8c8d; margin: auto;">Results will appear here</div>';
      return;
  }

  const maxWins = Math.max(...gameState.totalWins, 1);
  const chartHeight = 250;

  gameState.totalWins.forEach((wins, index) => {
      const barHeight = (wins / maxWins) * chartHeight;
      
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.height = `${barHeight}px`;
      
      // Color coding: gold for money printer player, blue for others
      if (gameState.mode === 'printer' && index === 0) {
          bar.style.background = 'linear-gradient(135deg, #f39c12, #e67e22)';
      } else {
          bar.style.background = 'linear-gradient(135deg, #3498db, #2980b9)';
      }
      
      const value = document.createElement('div');
      value.className = 'bar-value';
      value.textContent = wins;
      bar.appendChild(value);

      const label = document.createElement('div');
      label.className = 'bar-label';
      label.textContent = `P${index + 1}`;
      bar.appendChild(label);

      chartContent.appendChild(bar);
  });
}

function updateStatus() {
  document.getElementById('currentSim').textContent = gameState.currentSim;
  document.getElementById('totalSims').textContent = gameState.currentSim;
  
  // Find the player with the most wins so far
  const maxWins = Math.max(...gameState.totalWins);
  const leadingPlayerIndex = gameState.totalWins.findIndex(wins => wins === maxWins);
  document.getElementById('currentWinner').textContent = 
      gameState.currentSim > 0 && maxWins > 0 ? `Player ${leadingPlayerIndex + 1}` : '-';
  
  // Update bailouts used (shows current game's usage)
  const bailoutsElement = document.getElementById('printerBailoutsUsed');
  if (gameState.mode === 'printer') {
      bailoutsElement.textContent = `${gameState.currentGameBailoutsUsed}/${gameState.printerBailouts}`;
  } else {
      bailoutsElement.textContent = '-';
  }
}

function openAboutModal() {
  document.getElementById('aboutModal').classList.add('active');
}

function closeAboutModal(event) {
  if (!event || event.target === document.getElementById('aboutModal')) {
      document.getElementById('aboutModal').classList.remove('active');
  }
}

async function runSimulation() {
  if (gameState.isRunning) return;
  
  gameState.isRunning = true;
  gameState.isPaused = false;
  document.querySelector('.controls-panel').classList.add('running');

  // Reset if starting fresh
  if (gameState.currentSim === 0) {
      gameState.totalWins = new Array(gameState.playerCount).fill(0);
      gameState.totalChipsIssued = new Array(gameState.playerCount).fill(0);
      gameState.totalChipsEndedWith = new Array(gameState.playerCount).fill(0);
  }

  while (gameState.currentSim < gameState.simCount && gameState.isRunning && !gameState.isPaused) {
      const winner = await runSingleGame();
      
      if (winner !== null) {
          gameState.totalWins[winner - 1]++;
      }
      gameState.currentSim++;
      
      updateChipChart();
      updateWinsChart();
      updateStatus();

      // Add delay for visualization
      await new Promise(resolve => setTimeout(resolve, 100));
  }

  if (gameState.currentSim >= gameState.simCount) {
      gameState.isRunning = false;
      document.querySelector('.controls-panel').classList.remove('running');
      // Final update to show chips issued stats
      updateChipChart();
  }
}

function pauseSimulation() {
  gameState.isPaused = !gameState.isPaused;
  const button = event.target;
  button.textContent = gameState.isPaused ? '▶ Resume' : '⏸ Pause';
  
  if (!gameState.isPaused && gameState.isRunning) {
      runSimulation();
  }
}

function resetSimulation() {
  gameState.isRunning = false;
  gameState.isPaused = false;
  gameState.currentSim = 0;
  gameState.totalWins = new Array(gameState.playerCount).fill(0);
  gameState.totalChipsIssued = new Array(gameState.playerCount).fill(0);
  gameState.totalChipsEndedWith = new Array(gameState.playerCount).fill(0);
  
  document.querySelector('.controls-panel').classList.remove('running');
  document.querySelector('.btn-secondary').textContent = '⏸ Pause';
  
  initializePlayers();
  updateChipChart();
  updateWinsChart();
  updateStatus();
}

function switchTab(tabName) {
  // Hide all tabs
  document.querySelectorAll('.tab-content').forEach(tab => {
      tab.classList.remove('active');
  });
  
  // Remove active class from all buttons
  document.querySelectorAll('.tab-button').forEach(button => {
      button.classList.remove('active');
  });
  
  // Show selected tab
  document.getElementById(`${tabName}-tab`).classList.add('active');
  
  // Add active class to selected button
  event.target.classList.add('active');
  
  // Initialize scatter plot if switching to science tab
  if (tabName === 'science' && !superSimState.canvas) {
      initializeScatterPlot();
      initializeEconomicChart();
  }
}

function initializeScatterPlot() {
  superSimState.canvas = document.getElementById('scatterPlot');
  superSimState.ctx = superSimState.canvas.getContext('2d');
  
  // Set canvas size to fit within container
  const container = superSimState.canvas.parentElement;
  const containerWidth = Math.min(container.clientWidth - 50, 1000); // Max width constraint
  const containerHeight = container.clientHeight - 80;
  
  superSimState.canvas.width = containerWidth;
  superSimState.canvas.height = containerHeight;
  
  drawScatterPlot();
}

function initializeEconomicChart() {
  superSimState.economicCanvas = document.getElementById('economicChart');
  superSimState.economicCtx = superSimState.economicCanvas.getContext('2d');
  
  // Set canvas size to fit within container
  const container = superSimState.economicCanvas.parentElement;
  const containerWidth = Math.min(container.clientWidth - 50, 1000);
  const containerHeight = container.clientHeight - 80;
  
  superSimState.economicCanvas.width = containerWidth;
  superSimState.economicCanvas.height = containerHeight;
  
  drawEconomicChart();
}

function drawScatterPlot() {
  const ctx = superSimState.ctx;
  const canvas = superSimState.canvas;
  
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Set up plot area
  const padding = 60;
  const plotWidth = canvas.width - (padding * 2);
  const plotHeight = canvas.height - (padding * 2);
  
  // Draw axes
  ctx.strokeStyle = '#2c3e50';
  ctx.lineWidth = 2;
  ctx.beginPath();
  // X-axis
  ctx.moveTo(padding, canvas.height - padding);
  ctx.lineTo(canvas.width - padding, canvas.height - padding);
  // Y-axis
  ctx.moveTo(padding, padding);
  ctx.lineTo(padding, canvas.height - padding);
  ctx.stroke();
  
  // Draw grid and labels
  ctx.strokeStyle = '#ecf0f1';
  ctx.lineWidth = 1;
  ctx.fillStyle = '#7f8c8d';
  ctx.font = '12px Arial';
  
  // X-axis labels (0-20 bailouts)
  for (let i = 0; i <= 20; i += 5) {
      const x = padding + (i / 20) * plotWidth;
      ctx.beginPath();
      ctx.moveTo(x, canvas.height - padding);
      ctx.lineTo(x, padding);
      ctx.stroke();
      
      ctx.fillText(i, x - 5, canvas.height - padding + 20);
  }
  
  // Y-axis labels (0-100%)
  for (let i = 0; i <= 100; i += 20) {
      const y = canvas.height - padding - (i / 100) * plotHeight;
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(canvas.width - padding, y);
      ctx.stroke();
      
      ctx.fillText(i + '%', 10, y + 5);
  }
  
  // Draw axis titles
  ctx.fillStyle = '#2c3e50';
  ctx.font = '14px Arial';
  ctx.fillText('Number of Bailouts', canvas.width / 2 - 50, canvas.height - 10);
  
  ctx.save();
  ctx.translate(20, canvas.height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Player 1 Win Percentage', -80, 0);
  ctx.restore();
  
  // Draw primary data points (win percentage)
  superSimState.scatterData.forEach(point => {
      const x = padding + (point.bailouts / 20) * plotWidth;
      const y = canvas.height - padding - (point.winPercentage / 100) * plotHeight;
      
      ctx.fillStyle = '#3498db';
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, 2 * Math.PI);
      ctx.fill();
  });
  
  // Draw wealth overlay data if enabled
  const activeOverlays = Object.keys(superSimState.wealthOverlays).filter(key => superSimState.wealthOverlays[key]);
  
  if (activeOverlays.length > 0) {
      // Calculate range for right y-axis
      const allWealthValues = [];
      activeOverlays.forEach(metric => {
          superSimState.scatterData.forEach(point => {
              if (point.wealthMetrics) {
                  allWealthValues.push(point.wealthMetrics[metric]);
              }
          });
      });
      
      if (allWealthValues.length > 0) {
          const maxWealthValue = Math.max(...allWealthValues);
          const minWealthValue = Math.min(...allWealthValues);
          const wealthRange = maxWealthValue - minWealthValue || 1;
          
          // Draw right y-axis
          ctx.strokeStyle = '#e74c3c';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(canvas.width - padding, padding);
          ctx.lineTo(canvas.width - padding, canvas.height - padding);
          ctx.stroke();
          
          // Draw right y-axis labels
          ctx.fillStyle = '#e74c3c';
          ctx.font = '12px Arial';
          for (let i = 0; i <= 5; i++) {
              const value = minWealthValue + (i / 5) * wealthRange;
              const y = canvas.height - padding - (i / 5) * plotHeight;
              ctx.fillText(Math.round(value * 10) / 10, canvas.width - padding + 10, y + 5);
          }
          
          // Draw wealth overlay points
          const colors = ['#e74c3c', '#f39c12', '#9b59b6', '#1abc9c'];
          activeOverlays.forEach((metric, index) => {
              const color = colors[index % colors.length];
              superSimState.scatterData.forEach(point => {
                  if (point.wealthMetrics) {
                      const x = padding + (point.bailouts / 20) * plotWidth;
                      const normalizedValue = (point.wealthMetrics[metric] - minWealthValue) / wealthRange;
                      const y = canvas.height - padding - normalizedValue * plotHeight;
                      
                      ctx.fillStyle = color;
                      ctx.beginPath();
                      ctx.arc(x, y, 3, 0, 2 * Math.PI);
                      ctx.fill();
                      
                      // Draw connecting line
                      ctx.strokeStyle = color;
                      ctx.lineWidth = 1;
                      if (point.bailouts > 0) {
                          const prevPoint = superSimState.scatterData.find(p => p.bailouts === point.bailouts - 1);
                          if (prevPoint && prevPoint.wealthMetrics) {
                              const prevX = padding + ((point.bailouts - 1) / 20) * plotWidth;
                              const prevNormalizedValue = (prevPoint.wealthMetrics[metric] - minWealthValue) / wealthRange;
                              const prevY = canvas.height - padding - prevNormalizedValue * plotHeight;
                              
                              ctx.beginPath();
                              ctx.moveTo(prevX, prevY);
                              ctx.lineTo(x, y);
                              ctx.stroke();
                          }
                      }
                  }
              });
          });
          
          // Draw legend for active overlays
          ctx.fillStyle = '#2c3e50';
          ctx.font = '11px Arial';
          activeOverlays.forEach((metric, index) => {
              const color = colors[index % colors.length];
              const legendY = 20 + index * 15;
              
              ctx.fillStyle = color;
              ctx.beginPath();
              ctx.arc(canvas.width - 150, legendY, 3, 0, 2 * Math.PI);
              ctx.fill();
              
              ctx.fillStyle = '#2c3e50';
              const labels = {
                  inequalityRatio: 'Inequality Ratio',
                  economyShare: 'Economy Share %',
                  avgPoverty: 'Avg Other Wealth',
                  totalAccumulated: 'P1 Total Wealth'
              };
              ctx.fillText(labels[metric], canvas.width - 140, legendY + 4);
          });
      }
  }
}

async function startSuperSimulation() {
  if (superSimState.isRunning) return;
  
  superSimState.isRunning = true;
  superSimState.isPaused = false;
  
  // Reset if starting fresh
  if (superSimState.currentBailouts === 0 && superSimState.currentSimInSet === 0) {
      superSimState.scatterData = [];
      superSimState.totalSimulations = 0;
  }
  
  // Run the super simulation
  for (let bailouts = superSimState.currentBailouts; bailouts <= 20 && superSimState.isRunning && !superSimState.isPaused; bailouts++) {
      superSimState.currentBailouts = bailouts;
      
      for (let simInSet = superSimState.currentSimInSet; simInSet < 20 && superSimState.isRunning && !superSimState.isPaused; simInSet++) {
          superSimState.currentSimInSet = simInSet;
          
          // Run one complete simulation with current bailout amount
          const result = await runSingleScientificSimulation(bailouts);
          
          // Add data point to scatter plot
          superSimState.scatterData.push({
              bailouts: bailouts,
              winPercentage: result.winPercentage,
              wealthMetrics: result.wealthMetrics
          });
          
          superSimState.totalSimulations++;
            updateSuperSimProgress();
  drawScatterPlot();
  drawEconomicChart();
          
          // Small delay for visualization
          await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      superSimState.currentSimInSet = 0; // Reset for next bailout amount
  }
  
  if (superSimState.currentBailouts > 20) {
      superSimState.isRunning = false;
      document.getElementById('superSimButton').textContent = '✅ Simulation Complete';
  }
}

async function runSingleScientificSimulation(bailoutAmount) {
  // Set up temporary game state for this scientific simulation
  const originalMode = gameState.mode;
  const originalBailouts = gameState.printerBailouts;
  const originalStakesProgression = gameState.stakesProgression;
  const originalStakesInterval = gameState.stakesInterval;
  const originalBailoutPercentage = gameState.bailoutPercentage;
  const originalPlayerCount = gameState.playerCount;
  
  gameState.mode = bailoutAmount > 0 ? 'printer' : 'fair';
  gameState.printerBailouts = bailoutAmount;
  gameState.stakesProgression = superSimState.stakesProgression;
  gameState.stakesInterval = superSimState.stakesInterval;
  gameState.bailoutPercentage = superSimState.bailoutPercentage;
  gameState.playerCount = superSimState.playerCount;
  
  // Reset win counters and wealth tracking
  const tempWins = new Array(superSimState.playerCount).fill(0);
  const tempTotalChipsIssued = new Array(superSimState.playerCount).fill(0);
  const tempTotalChipsEndedWith = new Array(superSimState.playerCount).fill(0);
  
  // Store original tracking arrays
  const originalTotalChipsIssued = [...gameState.totalChipsIssued];
  const originalTotalChipsEndedWith = [...gameState.totalChipsEndedWith];
  
  // Reset for this scientific simulation
  gameState.totalChipsIssued = new Array(superSimState.playerCount).fill(0);
  gameState.totalChipsEndedWith = new Array(superSimState.playerCount).fill(0);
  
  // Run the specified number of games
  for (let i = 0; i < gameState.simCount; i++) {
      const winner = await runSingleGame();
      if (winner !== null) {
          tempWins[winner - 1]++;
      }
  }
  
  // Capture wealth metrics
  const player1TotalChips = gameState.totalChipsEndedWith[0];
  const otherPlayersTotalChips = gameState.totalChipsEndedWith.slice(1).reduce((sum, chips) => sum + chips, 0);
  const avgOtherPlayerChips = otherPlayersTotalChips / (superSimState.playerCount - 1);
  const totalEconomyChips = gameState.totalChipsIssued.reduce((sum, chips) => sum + chips, 0);
  const totalChipsCreated = gameState.totalChipsIssued[0]; // Extra chips given to Player 1
  
  // Calculate wealth metrics
  const inequalityRatio = avgOtherPlayerChips > 0 ? player1TotalChips / avgOtherPlayerChips : 0;
  const economyShare = totalEconomyChips > 0 ? (player1TotalChips / totalEconomyChips) * 100 : 0;
  const avgPoverty = avgOtherPlayerChips;
  
  // Calculate Player 1's win percentage
  const player1WinPercentage = (tempWins[0] / gameState.simCount) * 100;
  
  // Restore original tracking arrays
  gameState.totalChipsIssued = originalTotalChipsIssued;
  gameState.totalChipsEndedWith = originalTotalChipsEndedWith;
  
  // Restore original game state
  gameState.mode = originalMode;
  gameState.printerBailouts = originalBailouts;
  gameState.stakesProgression = originalStakesProgression;
  gameState.stakesInterval = originalStakesInterval;
  gameState.bailoutPercentage = originalBailoutPercentage;
  gameState.playerCount = originalPlayerCount;
  
  return {
    winPercentage: player1WinPercentage,
    wealthMetrics: {
      inequalityRatio: inequalityRatio,
      economyShare: economyShare,
      avgPoverty: avgPoverty,
      totalAccumulated: player1TotalChips,
      totalChipsCreated: totalChipsCreated
    }
  };
}

function updateSuperSimProgress() {
  document.getElementById('currentBailouts').textContent = superSimState.currentBailouts;
  document.getElementById('currentSimInSet').textContent = `${superSimState.currentSimInSet + 1}/20`;
  
  const overallProgress = (superSimState.totalSimulations / 420) * 100;
  document.getElementById('overallProgress').style.width = overallProgress + '%';
  document.getElementById('overallProgressText').textContent = 
      `Running simulation ${superSimState.currentSimInSet + 1}/20 for ${superSimState.currentBailouts} bailouts - ${superSimState.totalSimulations}/420 complete`;
}

function pauseSuperSimulation() {
  superSimState.isPaused = !superSimState.isPaused;
  const button = document.getElementById('superPauseButton');
  button.textContent = superSimState.isPaused ? '▶ Resume' : '⏸ Pause';
  
  if (!superSimState.isPaused && superSimState.isRunning) {
      startSuperSimulation();
  }
}

function resetSuperSimulation() {
  superSimState.isRunning = false;
  superSimState.isPaused = false;
  superSimState.currentBailouts = 0;
  superSimState.currentSimInSet = 0;
  superSimState.totalSimulations = 0;
  superSimState.scatterData = [];
  
  document.getElementById('superSimButton').textContent = '▶ Start Super Simulation';
  document.getElementById('superPauseButton').textContent = '⏸ Pause';
  
  updateSuperSimProgress();
  if (superSimState.canvas) {
      drawScatterPlot();
  }
  if (superSimState.economicCanvas) {
      drawEconomicChart();
  }
}

function drawEconomicChart() {
  const ctx = superSimState.economicCtx;
  const canvas = superSimState.economicCanvas;
  
  if (!ctx || !canvas) return;
  
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Set up plot area
  const padding = 60;
  const plotWidth = canvas.width - (padding * 2);
  const plotHeight = canvas.height - (padding * 2);
  
  // Draw axes
  ctx.strokeStyle = '#2c3e50';
  ctx.lineWidth = 2;
  ctx.beginPath();
  // X-axis
  ctx.moveTo(padding, canvas.height - padding);
  ctx.lineTo(canvas.width - padding, canvas.height - padding);
  // Y-axis (left)
  ctx.moveTo(padding, padding);
  ctx.lineTo(padding, canvas.height - padding);
  // Y-axis (right)
  ctx.moveTo(canvas.width - padding, padding);
  ctx.lineTo(canvas.width - padding, canvas.height - padding);
  ctx.stroke();
  
  // Draw grid and labels
  ctx.strokeStyle = '#ecf0f1';
  ctx.lineWidth = 1;
  ctx.fillStyle = '#7f8c8d';
  ctx.font = '12px Arial';
  
  // X-axis labels (0-20 bailouts)
  for (let i = 0; i <= 20; i += 5) {
      const x = padding + (i / 20) * plotWidth;
      ctx.beginPath();
      ctx.moveTo(x, canvas.height - padding);
      ctx.lineTo(x, padding);
      ctx.stroke();
      
      ctx.fillText(i, x - 5, canvas.height - padding + 20);
  }
  
  // Left Y-axis labels (0-100% for win percentage and economy share)
  for (let i = 0; i <= 100; i += 20) {
      const y = canvas.height - padding - (i / 100) * plotHeight;
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(canvas.width - padding, y);
      ctx.stroke();
      
      ctx.fillText(i + '%', 10, y + 5);
  }
  
  // Draw axis titles
  ctx.fillStyle = '#2c3e50';
  ctx.font = '14px Arial';
  ctx.fillText('Number of Bailouts', canvas.width / 2 - 50, canvas.height - 10);
  
  ctx.save();
  ctx.translate(20, canvas.height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Percentage (%)', -50, 0);
  ctx.restore();
  
  if (superSimState.scatterData.length > 0) {
      // Calculate ranges for right y-axis (inequality ratio and avg poverty)
      const inequalityValues = superSimState.scatterData.map(p => p.wealthMetrics?.inequalityRatio || 0);
      const avgPovertyValues = superSimState.scatterData.map(p => p.wealthMetrics?.avgPoverty || 0);
      const maxInequality = Math.max(...inequalityValues);
      const maxAvgPoverty = Math.max(...avgPovertyValues);
      const rightAxisMax = Math.max(maxInequality, maxAvgPoverty);
      
      // Right Y-axis labels
      ctx.fillStyle = '#e74c3c';
      ctx.font = '12px Arial';
      for (let i = 0; i <= 5; i++) {
          const value = (i / 5) * rightAxisMax;
          const y = canvas.height - padding - (i / 5) * plotHeight;
          ctx.fillText(Math.round(value * 10) / 10, canvas.width - padding + 10, y + 5);
      }
      
      // Right axis title
      ctx.save();
      ctx.translate(canvas.width - 20, canvas.height / 2);
      ctx.rotate(Math.PI / 2);
      ctx.fillText('Ratio / Chips', -40, 0);
      ctx.restore();
      
      // Define metrics to plot
      const metrics = [
          {
              key: 'winPercentage',
              color: '#3498db',
              label: 'Win %',
              axis: 'left',
              max: 100
          },
          {
              key: 'economyShare',
              color: '#2ecc71',
              label: 'Economy Share %',
              axis: 'left',
              max: 100,
              getValue: (point) => point.wealthMetrics?.economyShare || 0
          },
          {
              key: 'inequalityRatio',
              color: '#e74c3c',
              label: 'Inequality Ratio',
              axis: 'right',
              max: rightAxisMax,
              getValue: (point) => point.wealthMetrics?.inequalityRatio || 0
          },
          {
              key: 'avgPoverty',
              color: '#f39c12',
              label: 'Avg Other Player Wealth',
              axis: 'right',
              max: rightAxisMax,
              getValue: (point) => point.wealthMetrics?.avgPoverty || 0
          }
      ];
      
      // Sort data by bailouts for line drawing
      const sortedData = [...superSimState.scatterData].sort((a, b) => a.bailouts - b.bailouts);
      
      // Draw lines and points for each metric
      metrics.forEach(metric => {
          ctx.strokeStyle = metric.color;
          ctx.fillStyle = metric.color;
          ctx.lineWidth = 2;
          
          // Draw line
          ctx.beginPath();
          sortedData.forEach((point, index) => {
              const x = padding + (point.bailouts / 20) * plotWidth;
              const value = metric.getValue ? metric.getValue(point) : point[metric.key];
              const y = canvas.height - padding - (value / metric.max) * plotHeight;
              
              if (index === 0) {
                  ctx.moveTo(x, y);
              } else {
                  ctx.lineTo(x, y);
              }
          });
          ctx.stroke();
          
          // Draw points
          sortedData.forEach(point => {
              const x = padding + (point.bailouts / 20) * plotWidth;
              const value = metric.getValue ? metric.getValue(point) : point[metric.key];
              const y = canvas.height - padding - (value / metric.max) * plotHeight;
              
              ctx.beginPath();
              ctx.arc(x, y, 3, 0, 2 * Math.PI);
              ctx.fill();
          });
      });
      
      // Draw legend
      ctx.fillStyle = '#2c3e50';
      ctx.font = '11px Arial';
      metrics.forEach((metric, index) => {
          const legendY = 20 + index * 15;
          
          ctx.fillStyle = metric.color;
          ctx.beginPath();
          ctx.arc(canvas.width - 200, legendY, 3, 0, 2 * Math.PI);
          ctx.fill();
          
          // Draw short line
          ctx.beginPath();
          ctx.moveTo(canvas.width - 205, legendY);
          ctx.lineTo(canvas.width - 195, legendY);
          ctx.stroke();
          
          ctx.fillStyle = '#2c3e50';
          ctx.fillText(`${metric.label} (${metric.axis})`, canvas.width - 190, legendY + 4);
      });
  }
}

function setScienceStakesProgression(progression) {
  superSimState.stakesProgression = progression;
  document.querySelectorAll('input[name="scienceStakes"]').forEach(input => {
      input.closest('.mode-option').classList.remove('active');
  });
  event.target.closest('.mode-option').classList.add('active');
  document.querySelector(`input[name="scienceStakes"][value="${progression}"]`).checked = true;
}

// Initialize on page load
window.addEventListener('load', () => {
  gameState.totalWins = new Array(gameState.playerCount).fill(0);
  gameState.totalChipsIssued = new Array(gameState.playerCount).fill(0);
  gameState.totalChipsEndedWith = new Array(gameState.playerCount).fill(0);
  initializePlayers();
  updateChipChart();
  updateWinsChart();
  updateStatus();
});
</script>
</body>
</html>