{
  "name": "Rust",
  "color": "#CE412B",
  "icon": "rust",
  "snippets": {
    "hello-world": "fn main() {\n    println!(\"Hello, World!\");\n}",
    "variables": "// Rust uses immutable by default\nlet name = \"John\";        // Immutable\nlet mut age = 30;          // Mutable with 'mut'\nlet items: Vec<String> = Vec::new();\nconst PI: f64 = 3.14159;   // Compile-time constant\n\n// Type inference is powerful\nlet message = \"Hello\";     // Infers &str\nlet numbers = vec![1, 2, 3]; // Infers Vec<i32>",
    "strings": "let name = \"john doe\";\n\n// String manipulation\nlet formatted = name.to_uppercase();\nlet title_case: String = name\n    .split_whitespace()\n    .map(|s| {\n        let mut c = s.chars();\n        match c.next() {\n            None => String::new(),\n            Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),\n        }\n    })\n    .collect::<Vec<_>>()\n    .join(\" \");\n\n// String formatting\nlet message = format!(\"Welcome, {}!\", name);\n\n// String methods\nname.contains(\"doe\");      // true\nname.split_whitespace();   // iterator\n\"hello\".repeat(3);         // \"hellohellohello\"\n\n// String vs &str (important!)\nlet s: String = String::from(\"owned\");\nlet slice: &str = \"borrowed\";",
    "conditionals": "if age >= 18 && has_license {\n    println!(\"Can drive\");\n} else if age >= 16 {\n    println!(\"Can get permit\");\n} else {\n    println!(\"Too young\");\n}\n\n// if is an expression (returns value)\nlet status = if age >= 18 { \"adult\" } else { \"minor\" };\n\n// No ternary operator - use if expression\nlet category = if age >= 18 {\n    \"adult\"\n} else {\n    \"minor\"\n};\n\n// Pattern matching in if let\nif let Some(value) = optional_value {\n    println!(\"Got: {}\", value);\n}",
    "case-statements": "// Rust match (exhaustive pattern matching)\nlet day = \"Monday\";\n\nlet result = match day {\n    \"Monday\" | \"Tuesday\" | \"Wednesday\" | \"Thursday\" | \"Friday\" => \"Weekday\",\n    \"Saturday\" | \"Sunday\" => \"Weekend\",\n    _ => \"Invalid day\",\n};\n\n// Match with ranges\nlet score = 85;\n\nlet grade = match score {\n    90..=100 => \"A\",\n    80..=89 => \"B\",\n    70..=79 => \"C\",\n    60..=69 => \"D\",\n    _ => \"F\",\n};\n\n// Match on types (with enums)\nenum Value {\n    Number(i32),\n    Text(String),\n    Boolean(bool),\n}\n\nlet val = Value::Number(42);\n\nmatch val {\n    Value::Number(n) => println!(\"Number: {}\", n),\n    Value::Text(s) => println!(\"Text: {}\", s),\n    Value::Boolean(b) => println!(\"Boolean: {}\", b),\n}\n\n// Match with guards\nmatch score {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    _ => \"C or below\",\n}",
    "arrays": "// Arrays (fixed size, stack allocated)\nlet numbers: [i32; 5] = [1, 2, 3, 4, 5];\n\n// Vectors (dynamic, heap allocated)\nlet mut vec = vec![1, 2, 3, 4, 5];\n\n// Adding elements\nvec.push(6);\nvec.insert(0, 0);\n\n// Accessing (with bounds checking)\nlet first = vec[0];\nlet last = vec[vec.len() - 1];\n\n// Safe access\nlet first = vec.first();  // Option<&i32>\nlet last = vec.last();    // Option<&i32>\n\n// Slicing\nlet slice = &vec[1..4];   // [2, 3, 4]\n\n// Iterating\nfor num in &vec {\n    println!(\"{}\", num);\n}",
    "hashes": "use std::collections::HashMap;\n\n// Creating HashMap\nlet mut ages = HashMap::new();\nages.insert(\"John\", 30);\nages.insert(\"Jane\", 28);\n\n// Or with collect\nlet ages: HashMap<_, _> = vec![\n    (\"John\", 30),\n    (\"Jane\", 28),\n].into_iter().collect();\n\n// Access\nlet john_age = ages.get(\"John\");  // Option<&i32>\nlet has_jane = ages.contains_key(\"Jane\");\n\n// Iteration\nfor (name, age) in &ages {\n    println!(\"{}: {}\", name, age);\n}\n\n// Entry API for insert/update\nages.entry(\"John\").or_insert(30);\nages.entry(\"Bob\").and_modify(|a| *a += 1).or_insert(25);",
    "iteration": "let names = vec![\"Alice\", \"Bob\", \"Charlie\"];\n\n// Iterator (idiomatic)\nfor name in &names {\n    println!(\"{}\", name);\n}\n\n// Iterator with index\nfor (i, name) in names.iter().enumerate() {\n    println!(\"{}: {}\", i, name);\n}\n\n// Range\nfor i in 0..5 {\n    println!(\"{}\", i);\n}\n\n// Inclusive range\nfor i in 0..=5 {\n    println!(\"{}\", i);\n}\n\n// while loop\nwhile age < 18 {\n    age += 1;\n}\n\n// loop (infinite, use break)\nloop {\n    // break to exit\n}",
    "filtering": "let numbers = vec![1, 2, 3, 4, 5];\n\n// Filter with iterator (idiomatic)\nlet evens: Vec<_> = numbers\n    .iter()\n    .filter(|n| *n % 2 == 0)\n    .collect();\n\n// Map\nlet doubled: Vec<_> = numbers\n    .iter()\n    .map(|n| n * 2)\n    .collect();\n\n// Chain operations\nlet result: Vec<_> = numbers\n    .iter()\n    .filter(|n| *n % 2 == 0)\n    .map(|n| n * 2)\n    .collect();\n\n// Other iterator methods\nnumbers.iter().any(|n| n % 2 == 0);  // true\nnumbers.iter().all(|n| *n > 0);       // true\nnumbers.iter().find(|n| **n > 3);     // Some(&4)\nnumbers.iter().sum::<i32>();          // 15",
    "classes": "// Rust uses structs instead of classes\nstruct Person {\n    name: String,\n    age: u32,\n}\n\nimpl Person {\n    // Associated function (like static method)\n    fn new(name: String, age: u32) -> Self {\n        Person { name, age }\n    }\n    \n    // Method (takes &self)\n    fn introduce(&self) {\n        println!(\"Hi, I'm {}\", self.name);\n    }\n    \n    fn is_adult(&self) -> bool {\n        self.age >= 18\n    }\n    \n    // Mutable method\n    fn have_birthday(&mut self) {\n        self.age += 1;\n    }\n}\n\nlet person = Person::new(String::from(\"Alice\"), 25);\nperson.introduce();",
    "getters-setters": "struct Person {\n    name: String,\n    age: u32,\n}\n\nimpl Person {\n    // Constructor\n    fn new(name: String, age: u32) -> Self {\n        Person { name, age }\n    }\n    \n    // Getter (by convention, no 'get' prefix)\n    fn name(&self) -> &str {\n        &self.name\n    }\n    \n    fn age(&self) -> u32 {\n        self.age\n    }\n    \n    // Setter (takes mutable reference)\n    fn set_name(&mut self, name: String) {\n        self.name = name;\n    }\n    \n    fn set_age(&mut self, age: u32) {\n        if age < 150 {\n            self.age = age;\n        }\n    }\n}\n\n// Or use pub fields for simple cases\npub struct Point {\n    pub x: f64,\n    pub y: f64,\n}",
    "inheritance": "// Rust has NO inheritance! Use composition and traits\n\nstruct Animal {\n    name: String,\n}\n\nimpl Animal {\n    fn new(name: String) -> Self {\n        Animal { name }\n    }\n    \n    fn speak(&self) {\n        println!(\"Some sound\");\n    }\n}\n\n// Composition (embedding)\nstruct Dog {\n    animal: Animal,  // Composition\n}\n\nimpl Dog {\n    fn new(name: String) -> Self {\n        Dog {\n            animal: Animal::new(name),\n        }\n    }\n    \n    fn speak(&self) {\n        println!(\"{} says Woof!\", self.animal.name);\n    }\n    \n    fn fetch(&self) {\n        println!(\"{} fetches the ball\", self.animal.name);\n    }\n}\n\nlet dog = Dog::new(String::from(\"Buddy\"));\ndog.speak();",
    "modules": "// Rust uses traits (like interfaces)\n\ntrait Flyable {\n    fn fly(&self);\n}\n\ntrait Swimmable {\n    fn swim(&self);\n}\n\nstruct Duck {\n    name: String,\n}\n\n// Implement traits\nimpl Flyable for Duck {\n    fn fly(&self) {\n        println!(\"Duck flies\");\n    }\n}\n\nimpl Swimmable for Duck {\n    fn swim(&self) {\n        println!(\"Duck swims\");\n    }\n}\n\n// Trait bounds (generic constraints)\nfn make_it_fly<T: Flyable>(thing: &T) {\n    thing.fly();\n}\n\n// Multiple trait bounds\nfn make_it_fly_and_swim<T: Flyable + Swimmable>(thing: &T) {\n    thing.fly();\n    thing.swim();\n}",
    "file-io": "use std::fs;\nuse std::io::{self, Read, Write};\n\n// Reading entire file (simple)\nlet content = fs::read_to_string(\"data.txt\")?;\n\n// Writing to file\nfs::write(\"output.txt\", \"Hello, World!\")?;\n\n// Reading line by line\nuse std::io::BufRead;\n\nlet file = fs::File::open(\"data.txt\")?;\nlet reader = io::BufReader::new(file);\n\nfor line in reader.lines() {\n    let line = line?;\n    println!(\"{}\", line);\n}\n\n// Writing with file handle\nlet mut file = fs::File::create(\"output.txt\")?;\nfile.write_all(b\"Hello, World!\")?;\n\n// Check if file exists\nuse std::path::Path;\n\nif Path::new(\"data.txt\").exists() {\n    println!(\"File exists\");\n}\n\n// ? operator propagates errors\n// Result<T, E> for error handling",
    "json": "use serde::{Deserialize, Serialize};\nuse serde_json;\n\n// Define structs with derives\n#[derive(Serialize, Deserialize, Debug)]\nstruct Person {\n    name: String,\n    age: u32,\n}\n\n// Parse JSON\nlet json_string = r#\"{\"name\":\"Alice\",\"age\":30}\"#;\nlet person: Person = serde_json::from_str(json_string)?;\n\nprintln!(\"Name: {}\", person.name);\nprintln!(\"Age: {}\", person.age);\n\n// Convert to JSON\nlet person = Person {\n    name: String::from(\"Bob\"),\n    age: 25,\n};\nlet json = serde_json::to_string(&person)?;\n\n// Pretty print\nlet json = serde_json::to_string_pretty(&person)?;\n\n// Untyped JSON\nuse serde_json::Value;\n\nlet v: Value = serde_json::from_str(json_string)?;\nlet name = v[\"name\"].as_str().unwrap();\nlet age = v[\"age\"].as_u64().unwrap();",
    "threading": "use std::thread;\nuse std::sync::{Arc, Mutex};\n\n// Create thread\nlet handle = thread::spawn(|| {\n    println!(\"Running in thread\");\n});\nhandle.join().unwrap();\n\n// Thread with shared state (Arc = Atomic Reference Counted)\nlet counter = Arc::new(Mutex::new(0));\nlet mut handles = vec![];\n\nfor _ in 0..5 {\n    let counter = Arc::clone(&counter);\n    let handle = thread::spawn(move || {\n        let mut num = counter.lock().unwrap();\n        *num += 1;\n    });\n    handles.push(handle);\n}\n\nfor handle in handles {\n    handle.join().unwrap();\n}\n\nprintln!(\"Result: {}\", *counter.lock().unwrap());\n\n// Channels for communication\nuse std::sync::mpsc;\n\nlet (tx, rx) = mpsc::channel();\n\nthread::spawn(move || {\n    tx.send(\"Hello from thread\").unwrap();\n});\n\nlet msg = rx.recv().unwrap();\nprintln!(\"{}\", msg);",
    "metaprogramming": "// Rust metaprogramming uses macros, not runtime reflection\n\n// Declarative macros\nmacro_rules! say_hello {\n    () => {\n        println!(\"Hello!\");\n    };\n    ($name:expr) => {\n        println!(\"Hello, {}!\", $name);\n    };\n}\n\nsay_hello!();\nsay_hello!(\"Alice\");\n\n// Derive macros (common)\n#[derive(Debug, Clone, PartialEq)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n// Procedural macros (advanced, in separate crate)\n// Used by serde, diesel, etc.\n\n// Compile-time guarantees instead of runtime\n// Type system provides many metaprogramming features",
    "duck-typing": "// Rust uses static dispatch with traits (compile-time polymorphism)\n\ntrait Printable {\n    fn print(&self);\n}\n\nstruct Document;\nstruct Photo;\n\nimpl Printable for Document {\n    fn print(&self) {\n        println!(\"Printing document\");\n    }\n}\n\nimpl Printable for Photo {\n    fn print(&self) {\n        println!(\"Printing photo\");\n    }\n}\n\n// Static dispatch (no runtime cost)\nfn execute<T: Printable>(item: &T) {\n    item.print();\n}\n\n// Dynamic dispatch (when needed)\nfn execute_dyn(item: &dyn Printable) {\n    item.print();\n}\n\nexecute(&Document);\nexecute(&Photo);\n\n// Trait objects for heterogeneous collections\nlet items: Vec<Box<dyn Printable>> = vec![\n    Box::new(Document),\n    Box::new(Photo),\n];"
  }
}

