{
  "name": "Go",
  "color": "#00ADD8",
  "icon": "go",
  "history": "Created at Google in 2007 by Robert Griesemer, Rob Pike, and Ken Thompson, Go (Golang) was designed to address criticisms of other languages while maintaining their positive characteristics. Released as open-source in 2009 and reaching 1.0 in 2012, Go was built for the multicore, networked era. It combines the efficiency of C with the safety of Java and readability of Python. Go powers major infrastructure like Docker, Kubernetes, and Terraform. Known for its simplicity, fast compilation, and built-in concurrency via goroutines, Go has become the language of choice for cloud-native and DevOps tooling.",
  "keyFeatures": [
    "Fast compilation to native code",
    "Built-in concurrency with goroutines",
    "Channels for safe communication",
    "Simple, minimalist syntax",
    "Garbage collection",
    "Strong static typing with inference",
    "Standard library for networking and web",
    "No classes, only structs",
    "Implicit interface implementation",
    "Fast execution performance"
  ],
  "pros": [
    "Extremely fast compilation",
    "Excellent concurrency model",
    "Simple, easy to learn",
    "Great for microservices",
    "Single binary deployment",
    "Strong standard library",
    "Backed by Google",
    "Growing adoption in cloud/DevOps",
    "Fast execution speed",
    "Cross-platform compilation"
  ],
  "cons": [
    "No generics (until Go 1.18)",
    "Verbose error handling",
    "No traditional inheritance",
    "Limited metaprogramming",
    "Smaller ecosystem than Java/Python",
    "Opinionated formatting (gofmt)",
    "Less expressive than other languages",
    "No functional programming features"
  ],
  "snippets": {
    "hello-world": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")\n}",
    "comments": "// Single-line comment\n\n/* Multi-line comment\n   can span multiple lines\n   useful for longer explanations */\n\n// GoDoc comments (documentation)\n// Package comments go before package declaration\n\n// Greet returns a personalized greeting message.\n// The name parameter specifies who to greet.\nfunc Greet(name string) string {\n    return \"Hello, \" + name\n}\n\n// Go doesn't have built-in HEREDOC syntax\n// Use backticks for raw multi-line strings:\nsql := `\n  SELECT *\n  FROM users\n  WHERE age > 18\n  ORDER BY name\n`\n\n// Or concatenation:\nlongText := \"Line 1\\n\" +\n            \"Line 2\\n\" +\n            \"Line 3\"\n\n// Raw strings don't interpret escape sequences\npath := `C:\\Users\\Documents\\file.txt`",
    "variables": "// Go uses type inference with :=\nname := \"John\"\nage := 30\nitems := []string{}\n\n// Explicit types\nvar message string = \"Hello\"\n\n// Constants\nconst PI = 3.14159\n\n// Multiple declaration\nvar (\n    x int = 5\n    y int = 10\n)",
    "strings": "name := \"john doe\"\n\n// String manipulation\nimport \"strings\"\n\nformatted := strings.Title(name)\nupper := strings.ToUpper(name)\nparts := strings.Split(name, \" \")\ncontains := strings.Contains(name, \"doe\")\n\n// String formatting (like printf)\nimport \"fmt\"\nmessage := fmt.Sprintf(\"Welcome, %s!\", name)\n\n// String building for performance\nvar builder strings.Builder\nbuilder.WriteString(\"Hello \")\nbuilder.WriteString(name)\nresult := builder.String()",
    "conditionals": "if age >= 18 && hasLicense {\n    fmt.Println(\"Can drive\")\n} else if age >= 16 {\n    fmt.Println(\"Can get permit\")\n} else {\n    fmt.Println(\"Too young\")\n}\n\n// If with initialization\nif status := checkAge(age); status == \"adult\" {\n    fmt.Println(\"Adult\")\n}\n\n// Ternary alternative (Go has no ternary)\nvar status string\nif age >= 18 {\n    status = \"adult\"\n} else {\n    status = \"minor\"\n}",
    "case-statements": "// Go switch (cleaner than Java)\nday := \"Monday\"\n\nvar result string\nswitch day {\ncase \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\":\n    result = \"Weekday\"\ncase \"Saturday\", \"Sunday\":\n    result = \"Weekend\"\ndefault:\n    result = \"Invalid day\"\n}\n\n// Switch with conditions (no expression)\nswitch {\ncase age < 18:\n    fmt.Println(\"Minor\")\ncase age < 65:\n    fmt.Println(\"Adult\")\ndefault:\n    fmt.Println(\"Senior\")\n}\n\n// Type switch\nswitch v := value.(type) {\ncase string:\n    fmt.Println(\"String:\", v)\ncase int:\n    fmt.Println(\"Integer:\", v)\ndefault:\n    fmt.Println(\"Unknown type\")\n}",
    "arrays": "// Arrays (fixed size)\nvar numbers [5]int = [5]int{1, 2, 3, 4, 5}\n\n// Slices (dynamic arrays - most common)\nnumbers := []int{1, 2, 3, 4, 5}\n\n// Appending\nnumbers = append(numbers, 6)\nnumbers = append(numbers, 7, 8, 9)\n\n// Accessing\nfirst := numbers[0]\nlast := numbers[len(numbers)-1]\n\n// Slicing\nsubset := numbers[1:4]  // [2, 3, 4]\n\n// Make slice with capacity\nslice := make([]int, 0, 10)  // length 0, capacity 10",
    "hashes": "// Maps in Go\nages := map[string]int{\n    \"John\": 30,\n    \"Jane\": 28,\n}\n\n// Or with make\nages := make(map[string]int)\nages[\"John\"] = 30\nages[\"Jane\"] = 28\n\n// Access with comma-ok idiom\nage, exists := ages[\"John\"]\nif exists {\n    fmt.Println(\"John's age:\", age)\n}\n\n// Iteration\nfor name, age := range ages {\n    fmt.Printf(\"%s: %d\\n\", name, age)\n}\n\n// Delete\ndelete(ages, \"John\")",
    "iteration": "names := []string{\"Alice\", \"Bob\", \"Charlie\"}\n\n// Range with index and value\nfor i, name := range names {\n    fmt.Printf(\"%d: %s\\n\", i, name)\n}\n\n// Range with value only\nfor _, name := range names {\n    fmt.Println(name)\n}\n\n// Traditional for loop\nfor i := 0; i < len(names); i++ {\n    fmt.Println(names[i])\n}\n\n// While-style loop (no while keyword)\nfor age < 18 {\n    age++\n}\n\n// Infinite loop\nfor {\n    // break to exit\n}",
    "filtering": "numbers := []int{1, 2, 3, 4, 5}\n\n// Filter (manual)\nvar evens []int\nfor _, n := range numbers {\n    if n%2 == 0 {\n        evens = append(evens, n)\n    }\n}\n\n// Map (manual)\nvar doubled []int\nfor _, n := range numbers {\n    doubled = append(doubled, n*2)\n}\n\n// Filter and Map combined\nvar result []int\nfor _, n := range numbers {\n    if n%2 == 0 {\n        result = append(result, n*2)\n    }\n}\n\n// Or use generics (Go 1.18+)\nfunc Filter[T any](slice []T, fn func(T) bool) []T {\n    result := make([]T, 0)\n    for _, v := range slice {\n        if fn(v) {\n            result = append(result, v)\n        }\n    }\n    return result\n}",
    "classes": "// Go uses structs, not classes\ntype Person struct {\n    name string\n    age  int\n}\n\n// Constructor function (by convention)\nfunc NewPerson(name string, age int) *Person {\n    return &Person{\n        name: name,\n        age:  age,\n    }\n}\n\n// Methods (functions with receivers)\nfunc (p *Person) Introduce() {\n    fmt.Printf(\"Hi, I'm %s\\n\", p.name)\n}\n\nfunc (p *Person) IsAdult() bool {\n    return p.age >= 18\n}\n\n// Usage\nperson := NewPerson(\"Alice\", 25)\nperson.Introduce()",
    "getters-setters": "type Person struct {\n    name string  // lowercase = private\n    age  int\n}\n\n// Getter methods (by convention, no \"Get\" prefix)\nfunc (p *Person) Name() string {\n    return p.name\n}\n\nfunc (p *Person) Age() int {\n    return p.age\n}\n\n// Setter methods (by convention, use \"Set\" prefix)\nfunc (p *Person) SetName(name string) {\n    p.name = name\n}\n\nfunc (p *Person) SetAge(age int) {\n    p.age = age\n}\n\n// Or use exported fields (uppercase)\ntype Person struct {\n    Name string  // public\n    Age  int     // public\n}",
    "inheritance": "// Go has no inheritance, uses composition\n\ntype Animal struct {\n    name string\n}\n\nfunc (a *Animal) Speak() {\n    fmt.Println(\"Some sound\")\n}\n\n// Composition (embedding)\ntype Dog struct {\n    Animal  // embedded struct\n}\n\n// Override method\nfunc (d *Dog) Speak() {\n    fmt.Printf(\"%s says Woof!\\n\", d.name)\n}\n\nfunc (d *Dog) Fetch() {\n    fmt.Printf(\"%s fetches the ball\\n\", d.name)\n}\n\n// Usage\ndog := Dog{Animal{name: \"Buddy\"}}\ndog.Speak()",
    "modules": "// Go uses interfaces (implicit implementation)\n\ntype Flyable interface {\n    Fly()\n}\n\ntype Swimmable interface {\n    Swim()\n}\n\ntype Duck struct {\n    name string\n}\n\n// Implement interfaces (no \"implements\" keyword)\nfunc (d *Duck) Fly() {\n    fmt.Println(\"Duck flies\")\n}\n\nfunc (d *Duck) Swim() {\n    fmt.Println(\"Duck swims\")\n}\n\n// Multiple interface composition\ntype FlyingSwimmer interface {\n    Flyable\n    Swimmable\n}\n\n// Usage\nvar duck FlyingSwimmer = &Duck{name: \"Donald\"}\nduck.Fly()\nduck.Swim()",
    "file-io": "import (\n    \"os\"\n    \"io/ioutil\"  // or \"os\" in Go 1.16+\n    \"bufio\"\n)\n\n// Reading entire file\ncontent, err := os.ReadFile(\"data.txt\")\nif err != nil {\n    log.Fatal(err)\n}\n\n// Writing to file\nerr := os.WriteFile(\"output.txt\", []byte(\"Hello, World!\"), 0644)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Reading line by line\nfile, err := os.Open(\"data.txt\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer file.Close()\n\nscanner := bufio.NewScanner(file)\nfor scanner.Scan() {\n    fmt.Println(scanner.Text())\n}\n\n// Check if file exists\nif _, err := os.Stat(\"data.txt\"); err == nil {\n    fmt.Println(\"File exists\")\n}",
    "json": "import \"encoding/json\"\n\n// Parse JSON\njsonString := `{\"name\":\"Alice\",\"age\":30}`\n\nvar data map[string]interface{}\nerr := json.Unmarshal([]byte(jsonString), &data)\nif err != nil {\n    log.Fatal(err)\n}\n\nname := data[\"name\"].(string)\nage := data[\"age\"].(float64)\n\n// Struct-based parsing (type-safe)\ntype Person struct {\n    Name string `json:\"name\"`\n    Age  int    `json:\"age\"`\n}\n\nvar person Person\nerr := json.Unmarshal([]byte(jsonString), &person)\n\n// Convert to JSON\nperson := Person{Name: \"Bob\", Age: 25}\njsonBytes, err := json.Marshal(person)\njsonString := string(jsonBytes)\n\n// Pretty print\njsonBytes, err := json.MarshalIndent(person, \"\", \"  \")",
    "threading": "import \"sync\"\n\n// Goroutines (lightweight threads)\nfunc main() {\n    go func() {\n        fmt.Println(\"Running in goroutine\")\n    }()\n    \n    time.Sleep(time.Second)  // Wait for goroutine\n}\n\n// WaitGroup for synchronization\nvar wg sync.WaitGroup\n\nfor i := 0; i < 5; i++ {\n    wg.Add(1)\n    go func(id int) {\n        defer wg.Done()\n        fmt.Printf(\"Goroutine %d\\n\", id)\n    }(i)\n}\nwg.Wait()\n\n// Mutex for shared data\ntype Counter struct {\n    mu    sync.Mutex\n    count int\n}\n\nfunc (c *Counter) Increment() {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.count++\n}",
    "metaprogramming": "import \"reflect\"\n\n// Reflection (limited compared to Ruby)\nvalue := reflect.ValueOf(obj)\ntyp := reflect.TypeOf(obj)\n\n// Get struct fields\nfor i := 0; i < typ.NumField(); i++ {\n    field := typ.Field(i)\n    fmt.Println(field.Name, field.Type)\n}\n\n// Call method by name\nmethod := value.MethodByName(\"MethodName\")\nif method.IsValid() {\n    method.Call([]reflect.Value{})\n}\n\n// Struct tags (compile-time metadata)\ntype Person struct {\n    Name string `json:\"name\" db:\"person_name\"`\n    Age  int    `json:\"age\" db:\"person_age\"`\n}\n\n// Generate code with go:generate\n//go:generate stringer -type=Status",
    "duck-typing": "// Go uses structural typing with interfaces\n\ntype Printer interface {\n    Print()\n}\n\ntype Document struct{}\n\nfunc (d Document) Print() {\n    fmt.Println(\"Printing document\")\n}\n\ntype Photo struct{}\n\nfunc (p Photo) Print() {\n    fmt.Println(\"Printing photo\")\n}\n\n// Any type with Print() method satisfies Printer\nfunc Execute(p Printer) {\n    p.Print()\n}\n\n// Usage - no explicit \"implements\"\nExecute(Document{})\nExecute(Photo{})\n\n// Empty interface for any type\nfunc Accept(v interface{}) {\n    // Type assertion or type switch\n}"
  }
}

