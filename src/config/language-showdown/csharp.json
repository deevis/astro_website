{
  "name": "C#",
  "color": "#68217a",
  "icon": "csharp",
  "history": "Created by Anders Hejlsberg at Microsoft and released in 2000 as part of .NET Framework, C# was designed as a modern alternative to Java. Originally criticized as a Java clone, C# has evolved rapidly and independently. Major milestones include LINQ (C# 3, 2007), async/await (C# 5, 2012), pattern matching (C# 7), nullable reference types (C# 8), records (C# 9), and top-level statements (C# 9). With .NET Core (now .NET 5+), C# became cross-platform. Used by Unity game engine and enterprise applications worldwide, C# combines power, modern features, and excellent tooling.",
  "keyFeatures": [
    "Strong static typing with inference",
    "Automatic properties (get; set;)",
    "LINQ for querying collections",
    "Async/await for concurrency",
    "Garbage collection",
    "Pattern matching and records",
    "Nullable reference types (C# 8+)",
    "Properties instead of getters/setters",
    "Cross-platform (.NET 5+)",
    "Excellent Visual Studio integration"
  ],
  "pros": [
    "Modern language with rapid evolution",
    "Excellent tooling (Visual Studio)",
    "Strong type safety",
    "LINQ is incredibly powerful",
    "Great async/await support",
    "Cross-platform with .NET",
    "Unity for game development",
    "Large ecosystem and community",
    "Auto-properties reduce boilerplate",
    "Microsoft backing and support"
  ],
  "cons": [
    "Primarily tied to Microsoft ecosystem",
    "Windows-centric history (legacy)",
    "Slower than native languages",
    "GC pauses in performance-critical apps",
    "Verbosity compared to dynamic languages",
    ".NET versioning can be confusing",
    "Smaller adoption than Java/Python",
    "Enterprise focus may feel heavy for small projects"
  ],
  "snippets": {
    "hello-world": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(\"Hello, World!\");\n    }\n}",
    "variables": "// C# has strong typing with type inference\nstring name = \"John\";\nint age = 30;\nList<string> items = new List<string>();\nconst double PI = 3.14159;\n\n// Type inference with var\nvar message = \"Hello\";  // still strongly typed!\n\n// Nullable types\nint? nullableAge = null;\nstring? nullableName = null;  // C# 8+",
    "strings": "string name = \"john doe\";\n\n// String interpolation (clean!)\nstring message = $\"Welcome, {name}!\";  // Like TypeScript!\n\n// Rich string methods\nstring formatted = name.ToUpper();  // \"JOHN DOE\"\nstring[] parts = name.Split(' ');   // [\"john\", \"doe\"]\nbool contains = name.Contains(\"doe\");  // true\n\n// String builder for concatenation\nvar sb = new StringBuilder();\nsb.Append(\"Hello \").Append(name);",
    "conditionals": "if (age >= 18 && hasLicense)\n{\n    Console.WriteLine(\"Can drive\");\n}\nelse if (age >= 16)\n{\n    Console.WriteLine(\"Can get permit\");\n}\nelse\n{\n    Console.WriteLine(\"Too young\");\n}\n\n// Ternary\nstring status = age >= 18 ? \"adult\" : \"minor\";\n\n// Null-conditional operator\nstring? result = person?.Name?.ToUpper();  // Won't crash if null!",
    "case-statements": "// C# switch (traditional)\nstring day = \"Monday\";\nstring result;\n\nswitch (day)\n{\n    case \"Monday\":\n    case \"Tuesday\":\n    case \"Wednesday\":\n    case \"Thursday\":\n    case \"Friday\":\n        result = \"Weekday\";\n        break;\n    case \"Saturday\":\n    case \"Sunday\":\n        result = \"Weekend\";\n        break;\n    default:\n        result = \"Invalid day\";\n        break;\n}\n\n// C# 8+ switch expressions (much better!)\nstring result = day switch\n{\n    \"Monday\" or \"Tuesday\" or \"Wednesday\" or \"Thursday\" or \"Friday\" => \"Weekday\",\n    \"Saturday\" or \"Sunday\" => \"Weekend\",\n    _ => \"Invalid day\"\n};\n\n// Pattern matching with switch\nint score = 85;\n\nstring grade = score switch\n{\n    >= 90 => \"A\",\n    >= 80 => \"B\",\n    >= 70 => \"C\",\n    >= 60 => \"D\",\n    _ => \"F\"\n};\n\n// Type pattern matching\nobject value = 42;\n\nstring result = value switch\n{\n    string s => $\"String: {s}\",\n    int i => $\"Integer: {i}\",\n    double d => $\"Double: {d}\",\n    _ => \"Unknown type\"\n};",
    "arrays": "// Fixed size array\nint[] numbers = { 1, 2, 3, 4, 5 };\n\n// Dynamic List<T> (like ArrayList)\nvar list = new List<int> { 1, 2, 3, 4, 5 };\nlist.Add(6);\nlist.Insert(0, 0);  // Insert at beginning\n\n// Accessing\nint first = list[0];  // or list.First()\nint last = list[^1];  // C# 8+ index from end!\n\n// Slicing with ranges (C# 8+)\nvar slice = list[1..3];  // Elements 1 and 2\nvar lastTwo = list[^2..];  // Last 2 elements",
    "hashes": "// Dictionary<K, V>\nvar ages = new Dictionary<string, int>\n{\n    { \"John\", 30 },\n    { \"Jane\", 28 }\n};\n\n// Or with collection initializer (C# 6+)\nvar ages = new Dictionary<string, int>\n{\n    [\"John\"] = 30,\n    [\"Jane\"] = 28\n};\n\nint johnAge = ages[\"John\"];\nbool hasJane = ages.ContainsKey(\"Jane\");\n\n// Iteration\nforeach (var kvp in ages)\n{\n    Console.WriteLine($\"{kvp.Key}: {kvp.Value}\");\n}\n\n// LINQ transformations\nvar incremented = ages.ToDictionary(\n    kvp => kvp.Key, \n    kvp => kvp.Value + 1\n);",
    "iteration": "var names = new List<string> { \"Alice\", \"Bob\", \"Charlie\" };\n\n// foreach (most common)\nforeach (var name in names)\n{\n    Console.WriteLine(name);\n}\n\n// foreach with index (C# 7.0+)\nforeach (var (name, index) in names.Select((n, i) => (n, i)))\n{\n    Console.WriteLine($\"{index}: {name}\");\n}\n\n// Traditional for loop\nfor (int i = 0; i < names.Count; i++)\n{\n    Console.WriteLine($\"{i}: {names[i]}\");\n}\n\n// LINQ ForEach (on List<T>)\nnames.ForEach(name => Console.WriteLine(name));",
    "filtering": "var numbers = new List<int> { 1, 2, 3, 4, 5 };\n\n// LINQ - Language Integrated Query (powerful!)\nvar evens = numbers.Where(n => n % 2 == 0).ToList();\n\n// Map with Select\nvar doubled = numbers.Select(n => n * 2).ToList();\n\n// Chain operations (like Ruby/TypeScript)\nvar result = numbers\n    .Where(n => n % 2 == 0)\n    .Select(n => n * 2)\n    .ToList();\n\n// Other LINQ methods\nbool anyEven = numbers.Any(n => n % 2 == 0);\nbool allPositive = numbers.All(n => n > 0);\nint? firstGreater = numbers.FirstOrDefault(n => n > 3);\nint sum = numbers.Sum();",
    "classes": "public class Person\n{\n    private string name;\n    private int age;\n    \n    // Constructor\n    public Person(string name, int age)\n    {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public void Introduce()\n    {\n        Console.WriteLine($\"Hi, I'm {name}\");\n    }\n    \n    public bool IsAdult()\n    {\n        return age >= 18;\n    }\n}\n\nvar person = new Person(\"Alice\", 25);\nperson.Introduce();\n\n// C# 9+ records (immutable classes)\npublic record Person(string Name, int Age);",
    "getters-setters": "public class Person\n{\n    // Auto-implemented properties (C# magic!)\n    public string Name { get; set; }\n    public int Age { get; set; }\n    \n    // Read-only property\n    public string NameUpper { get { return Name.ToUpper(); } }\n    \n    // Expression-bodied property (C# 6+)\n    public bool IsAdult => Age >= 18;\n    \n    // Init-only property (C# 9+)\n    public string Id { get; init; }\n}\n\nvar person = new Person\n{\n    Name = \"Alice\",  // Clean initialization!\n    Age = 25,\n    Id = \"123\"\n};\n\nConsole.WriteLine(person.Name);  // No get/set methods needed!",
    "inheritance": "public class Animal\n{\n    public string Name { get; set; }\n    \n    public Animal(string name)\n    {\n        Name = name;\n    }\n    \n    public virtual void Speak()  // virtual for overriding\n    {\n        Console.WriteLine(\"Some sound\");\n    }\n}\n\npublic class Dog : Animal\n{\n    public Dog(string name) : base(name) { }\n    \n    public override void Speak()  // override keyword required\n    {\n        Console.WriteLine($\"{Name} says Woof!\");\n    }\n    \n    public void Fetch()\n    {\n        Console.WriteLine($\"{Name} fetches the ball\");\n    }\n}",
    "modules": "public interface IFlyable\n{\n    void Fly();\n}\n\npublic interface ISwimmable\n{\n    void Swim();\n}\n\npublic class Duck : IFlyable, ISwimmable\n{\n    public void Fly()\n    {\n        Console.WriteLine(\"Duck flies\");\n    }\n    \n    public void Swim()\n    {\n        Console.WriteLine(\"Duck swims\");\n    }\n}\n\n// C# 8+ default interface implementations\npublic interface ILogger\n{\n    void Log(string message)\n    {\n        Console.WriteLine($\"[LOG] {message}\");\n    }\n}",
    "file-io": "using System.IO;\n\n// Reading entire file (simple!)\nstring content = File.ReadAllText(\"data.txt\");\n\n// Writing to file (one-liner)\nFile.WriteAllText(\"output.txt\", \"Hello, World!\");\n\n// Reading all lines\nstring[] lines = File.ReadAllLines(\"data.txt\");\n\n// Reading line by line (memory efficient)\nforeach (string line in File.ReadLines(\"data.txt\"))\n{\n    Console.WriteLine(line);\n}\n\n// Append to file\nFile.AppendAllText(\"log.txt\", \"New log entry\\n\");\n\n// Check if file exists\nif (File.Exists(\"data.txt\"))\n{\n    var info = new FileInfo(\"data.txt\");\n    Console.WriteLine(info.Length);  // File size\n    Console.WriteLine(info.LastWriteTime);\n}\n\n// Using StreamReader/Writer (like Java try-with-resources)\nusing (var writer = new StreamWriter(\"output.txt\"))\n{\n    writer.WriteLine(\"Hello\");\n}  // Automatically closed",
    "json": "using System.Text.Json;\n// or using Newtonsoft.Json; (more popular)\n\n// Parse JSON string\nstring jsonString = \"{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30}\";\n\n// With System.Text.Json\nvar data = JsonSerializer.Deserialize<Dictionary<string, object>>(jsonString);\nstring name = data[\"name\"].ToString();\n\n// Or deserialize to a class\npublic class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\nvar person = JsonSerializer.Deserialize<Person>(jsonString);\nConsole.WriteLine(person.Name);  // \"Alice\"\n\n// Serialize to JSON\nvar bob = new Person { Name = \"Bob\", Age = 25 };\nstring json = JsonSerializer.Serialize(bob);\n\n// With Newtonsoft.Json (more features)\nvar person = JsonConvert.DeserializeObject<Person>(jsonString);\nstring json = JsonConvert.SerializeObject(bob, Formatting.Indented);\n\n// Parse array\nstring arrayJson = \"[1, 2, 3, 4, 5]\";\nvar numbers = JsonSerializer.Deserialize<List<int>>(arrayJson);",
    "threading": "using System.Threading;\n\n// Thread-safe with lock\npublic class Counter\n{\n    private int count = 0;\n    private readonly object lockObj = new object();\n    \n    public void Increment()\n    {\n        lock (lockObj)  // Simpler than synchronized!\n        {\n            count++;\n        }\n    }\n    \n    public int GetCount()\n    {\n        lock (lockObj) { return count; }\n    }\n}\n\n// Creating threads\nvar thread = new Thread(() =>\n{\n    Console.WriteLine(\"Running in thread\");\n});\nthread.Start();\nthread.Join();  // Wait for completion\n\n// Task-based (modern approach)\nvar task = Task.Run(() =>\n{\n    Console.WriteLine(\"Running in task\");\n});\nawait task;  // With async/await\n\n// Parallel processing\nParallel.For(0, 10, i =>\n{\n    Console.WriteLine($\"Thread {i}\");\n});",
    "metaprogramming": "using System.Reflection;\n\n// Reflection (better than Java)\nType type = obj.GetType();\nMethodInfo method = type.GetMethod(\"MethodName\");\nmethod.Invoke(obj, new object[] { \"argument\" });\n\n// Attributes (like Java annotations)\n[Serializable]\npublic class MyClass\n{\n    [Obsolete(\"Use NewMethod instead\")]\n    public void OldMethod() { }\n}\n\n// Dynamic type (runtime typing!)\ndynamic obj = GetSomeObject();\nobj.AnyMethod();  // No compile-time checking!\n\n// Expression trees (compile code at runtime)\nExpression<Func<int, int>> expr = x => x * 2;\n\n// Source generators (C# 9+) - compile-time code generation\n// Much more powerful than reflection",
    "duck-typing": "// C# uses interfaces (nominal typing)\npublic interface IPrintable\n{\n    void Print();\n}\n\npublic class Document : IPrintable\n{\n    public void Print()\n    {\n        Console.WriteLine(\"Printing document\");\n    }\n}\n\npublic class Printer\n{\n    public void Execute(IPrintable item)\n    {\n        item.Print();\n    }\n}\n\n// BUT C# has dynamic for duck typing!\npublic class Printer\n{\n    public void Execute(dynamic item)\n    {\n        item.Print();  // No interface needed! Runtime check.\n    }\n}\n\n// And generic constraints\npublic void Execute<T>(T item) where T : IPrintable\n{\n    item.Print();\n}"
  }
}
