{
  "name": "Python",
  "color": "#3776ab",
  "icon": "python",
  "snippets": {
    "hello-world": "print(\"Hello, World!\")",
    "variables": "# Python uses dynamic typing\nname = \"John\"\nage = 30\nitems = []\nPI = 3.14159  # Convention: UPPERCASE for constants\n\n# Everything is an object\ntype(name)  # <class 'str'>\ntype(age)   # <class 'int'>",
    "strings": "name = \"john doe\"\nformatted = name.title()\n\n# String formatting (multiple ways)\nmessage = f\"Welcome, {name}!\"  # f-strings (Python 3.6+)\nmessage = \"Welcome, {}!\".format(name)\n\n# Rich string methods\nname.upper()           # \"JOHN DOE\"\nname.split()           # [\"john\", \"doe\"]\n\"doe\" in name          # True\n\"hello\" * 3            # \"hellohellohello\"",
    "conditionals": "if age >= 18 and has_license:\n    print(\"Can drive\")\nelif age >= 16:\n    print(\"Can get permit\")\nelse:\n    print(\"Too young\")\n\n# Ternary\nstatus = \"adult\" if age >= 18 else \"minor\"\n\n# No statement modifiers like Ruby\n# Truthiness: False, None, 0, \"\", [], {} are falsy",
    "case-statements": "# Python 3.10+ match/case (pattern matching)\nday = \"Monday\"\n\nmatch day:\n    case \"Monday\" | \"Tuesday\" | \"Wednesday\" | \"Thursday\" | \"Friday\":\n        result = \"Weekday\"\n    case \"Saturday\" | \"Sunday\":\n        result = \"Weekend\"\n    case _:\n        result = \"Invalid day\"\n\n# Pattern matching with values\nscore = 85\n\nmatch score:\n    case x if 90 <= x <= 100:\n        grade = \"A\"\n    case x if 80 <= x < 90:\n        grade = \"B\"\n    case x if 70 <= x < 80:\n        grade = \"C\"\n    case _:\n        grade = \"D or F\"\n\n# Before Python 3.10, use if/elif\nif score >= 90:\n    grade = \"A\"\nelif score >= 80:\n    grade = \"B\"\nelse:\n    grade = \"C or below\"",
    "arrays": "# Python lists are dynamic\nnumbers = [1, 2, 3, 4, 5]\n\n# Adding elements\nnumbers.append(6)      # Add to end\nnumbers.insert(0, 0)   # Insert at index\n\n# Accessing\nfirst = numbers[0]\nlast = numbers[-1]     # Negative indices!\n\n# Slicing (powerful!)\nnumbers[1:4]           # [2, 3, 4]\nnumbers[::2]           # [1, 3, 5] - every 2nd element\nnumbers[::-1]          # Reverse",
    "hashes": "# Python dictionaries\nages = {\"john\": 30, \"jane\": 28}\n\n# Or with dict()\nages = dict(john=30, jane=28)\n\n# Access\njohn_age = ages[\"john\"]\njohn_age = ages.get(\"john\")  # Safer - returns None if missing\nhas_jane = \"jane\" in ages\n\n# Iteration\nfor name, age in ages.items():\n    print(f\"{name}: {age}\")\n\n# Dictionary comprehension\nages_plus_one = {name: age + 1 for name, age in ages.items()}",
    "iteration": "names = [\"Alice\", \"Bob\", \"Charlie\"]\n\n# for loop (idiomatic)\nfor name in names:\n    print(name)\n\n# enumerate for index\nfor i, name in enumerate(names):\n    print(f\"{i}: {name}\")\n\n# range for counting\nfor i in range(5):\n    print(i)\n\n# while loop\nwhile age < 18:\n    age += 1",
    "filtering": "numbers = [1, 2, 3, 4, 5]\n\n# List comprehensions (idiomatic)\nevens = [n for n in numbers if n % 2 == 0]\n\n# Map\ndoubled = [n * 2 for n in numbers]\n\n# Or with map/filter (functional style)\nevens = list(filter(lambda n: n % 2 == 0, numbers))\ndoubled = list(map(lambda n: n * 2, numbers))\n\n# Chain operations\nresult = [n * 2 for n in numbers if n % 2 == 0]\n\n# Other useful functions\nany(n % 2 == 0 for n in numbers)  # True\nall(n > 0 for n in numbers)       # True\nsum(numbers)                       # 15",
    "classes": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def introduce(self):\n        print(f\"Hi, I'm {self.name}\")\n    \n    def is_adult(self):\n        return self.age >= 18\n\nperson = Person(\"Alice\", 25)\nperson.introduce()",
    "getters-setters": "class Person:\n    def __init__(self, name, age):\n        self._name = name  # Convention: _ prefix for \"private\"\n        self._age = age\n    \n    # Property decorator (Pythonic way)\n    @property\n    def name(self):\n        return self._name\n    \n    @name.setter\n    def name(self, value):\n        self._name = value\n    \n    @property\n    def age(self):\n        return self._age\n    \n    @age.setter\n    def age(self, value):\n        if value < 0:\n            raise ValueError(\"Age cannot be negative\")\n        self._age = value\n\nperson = Person(\"Alice\", 25)\nprint(person.name)  # Looks like attribute access!\nperson.age = 26",
    "inheritance": "class Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        print(\"Some sound\")\n\nclass Dog(Animal):\n    def speak(self):\n        print(f\"{self.name} says Woof!\")\n    \n    def fetch(self):\n        print(f\"{self.name} fetches the ball\")\n\ndog = Dog(\"Buddy\")\ndog.speak()",
    "modules": "# Python uses multiple inheritance\n\nclass Flyable:\n    def fly(self):\n        print(f\"{self.__class__.__name__} flies\")\n\nclass Swimmable:\n    def swim(self):\n        print(f\"{self.__class__.__name__} swims\")\n\nclass Duck(Flyable, Swimmable):\n    pass\n\nduck = Duck()\nduck.fly()   # Duck flies\nduck.swim()  # Duck swims\n\n# Abstract base classes (like interfaces)\nfrom abc import ABC, abstractmethod\n\nclass Printable(ABC):\n    @abstractmethod\n    def print(self):\n        pass",
    "file-io": "# Reading entire file\nwith open(\"data.txt\", \"r\") as file:\n    content = file.read()\n\n# Or shorter\ncontent = open(\"data.txt\").read()\n\n# Writing to file\nwith open(\"output.txt\", \"w\") as file:\n    file.write(\"Hello, World!\")\n\n# Reading lines\nwith open(\"data.txt\", \"r\") as file:\n    for line in file:\n        print(line.strip())\n\n# Or read all lines\nlines = open(\"data.txt\").readlines()\n\n# Check if file exists\nimport os\nos.path.exists(\"data.txt\")\n\n# Path operations (modern way)\nfrom pathlib import Path\npath = Path(\"data.txt\")\nif path.exists():\n    content = path.read_text()\n    path.write_text(\"New content\")",
    "json": "import json\n\n# Parse JSON string\njson_string = '{\"name\":\"Alice\",\"age\":30}'\ndata = json.loads(json_string)\n\nname = data[\"name\"]  # \"Alice\"\nage = data[\"age\"]    # 30\n\n# Convert to JSON\nperson = {\"name\": \"Bob\", \"age\": 25}\njson_string = json.dumps(person)\n\n# Pretty print\njson_string = json.dumps(person, indent=2)\n\n# Read from file\nwith open(\"data.json\") as f:\n    data = json.load(f)\n\n# Write to file\nwith open(\"output.json\", \"w\") as f:\n    json.dump(person, f, indent=2)\n\n# Parse JSON array\narray_json = '[1, 2, 3, 4, 5]'\nnumbers = json.loads(array_json)",
    "threading": "import threading\n\n# Thread with function\ndef worker():\n    print(\"Running in thread\")\n\nthread = threading.Thread(target=worker)\nthread.start()\nthread.join()  # Wait for completion\n\n# Thread with Lock\nlock = threading.Lock()\n\ndef increment():\n    with lock:  # Automatically acquire/release\n        # Critical section\n        pass\n\n# Multiple threads\nthreads = []\nfor i in range(5):\n    t = threading.Thread(target=lambda: print(f\"Thread {i}\"))\n    threads.append(t)\n    t.start()\n\nfor t in threads:\n    t.join()\n\n# Python has GIL (Global Interpreter Lock)\n# For CPU-bound: use multiprocessing\n# For I/O-bound: threading works well",
    "metaprogramming": "# Dynamic attribute access\nobj = MyClass()\nsetattr(obj, \"name\", \"Alice\")\nname = getattr(obj, \"name\")\n\n# Call methods by name\nmethod = getattr(obj, \"method_name\")\nmethod()\n\n# Decorators (metaprogramming)\ndef timer(func):\n    def wrapper(*args, **kwargs):\n        import time\n        start = time.time()\n        result = func(*args, **kwargs)\n        print(f\"Took {time.time() - start}s\")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    pass\n\n# Metaclasses (advanced)\nclass Meta(type):\n    def __new__(cls, name, bases, attrs):\n        # Modify class creation\n        return super().__new__(cls, name, bases, attrs)\n\nclass MyClass(metaclass=Meta):\n    pass",
    "duck-typing": "# Python embraces duck typing\n\nclass Document:\n    def print(self):\n        print(\"Printing document\")\n\nclass Photo:\n    def print(self):\n        print(\"Printing photo\")\n\ndef execute(item):\n    # No type checking - just call the method\n    item.print()\n\nexecute(Document())\nexecute(Photo())\n\n# Check if method exists\nif hasattr(item, \"print\"):\n    item.print()\n\n# Type hints (optional, Python 3.5+)\nfrom typing import Protocol\n\nclass Printable(Protocol):\n    def print(self) -> None:\n        ...\n\ndef execute(item: Printable) -> None:\n    item.print()"
  }
}

