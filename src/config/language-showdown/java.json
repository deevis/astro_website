{
  "name": "Java",
  "color": "#f76707",
  "icon": "java",
  "snippets": {
    "hello-world": "public class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}",
    "variables": "// Java requires explicit types\nString name = \"John\";\nint age = 30;\nList<String> items = new ArrayList<>();\nfinal double PI = 3.14159;\n\n// Type inference (Java 10+)\nvar message = \"Hello\";",
    "strings": "String name = \"john doe\";\nString formatted = name.substring(0, 1).toUpperCase() \n                     + name.substring(1);\n\n// StringBuilder for concatenation\nStringBuilder sb = new StringBuilder();\nsb.append(\"Hello \").append(name);\n\n// String interpolation (Java 15+)\nString message = STR.\"Welcome, \\{name}!\";",
    "conditionals": "if (age >= 18 && hasLicense) {\n    System.out.println(\"Can drive\");\n} else if (age >= 16) {\n    System.out.println(\"Can get permit\");\n} else {\n    System.out.println(\"Too young\");\n}\n\n// Ternary\nString status = (age >= 18) ? \"adult\" : \"minor\";",
    "case-statements": "// Java switch (traditional)\nString day = \"Monday\";\nString result;\n\nswitch (day) {\n    case \"Monday\":\n    case \"Tuesday\":\n    case \"Wednesday\":\n    case \"Thursday\":\n    case \"Friday\":\n        result = \"Weekday\";\n        break;\n    case \"Saturday\":\n    case \"Sunday\":\n        result = \"Weekend\";\n        break;\n    default:\n        result = \"Invalid day\";\n}\n\n// Java 14+ switch expressions\nString result = switch (day) {\n    case \"Monday\", \"Tuesday\", \"Wednesday\", \n         \"Thursday\", \"Friday\" -> \"Weekday\";\n    case \"Saturday\", \"Sunday\" -> \"Weekend\";\n    default -> \"Invalid day\";\n};\n\n// Can only match on primitives, strings, enums\nint score = 85;\nswitch (score / 10) {\n    case 10:\n    case 9:\n        System.out.println(\"A\");\n        break;\n    case 8:\n        System.out.println(\"B\");\n        break;\n    default:\n        System.out.println(\"C or below\");\n}",
    "arrays": "// Fixed size\nint[] numbers = {1, 2, 3, 4, 5};\n\n// Dynamic size (ArrayList)\nList<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\n\n// Accessing\nint first = list.get(0);\nint last = list.get(list.size() - 1);",
    "hashes": "// Java Maps\nMap<String, Integer> ages = new HashMap<>();\nages.put(\"John\", 30);\nages.put(\"Jane\", 28);\n\nint johnAge = ages.get(\"John\");\nboolean hasJane = ages.containsKey(\"Jane\");\n\n// Iteration\nfor (Map.Entry<String, Integer> entry : ages.entrySet()) {\n    System.out.println(entry.getKey() + \": \" + entry.getValue());\n}",
    "iteration": "List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n// Traditional for loop\nfor (int i = 0; i < names.size(); i++) {\n    System.out.println(i + \": \" + names.get(i));\n}\n\n// Enhanced for loop\nfor (String name : names) {\n    System.out.println(name);\n}\n\n// Streams (Java 8+)\nnames.stream().forEach(name -> System.out.println(name));",
    "filtering": "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n// Filter\nList<Integer> evens = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .collect(Collectors.toList());\n\n// Map\nList<Integer> doubled = numbers.stream()\n    .map(n -> n * 2)\n    .collect(Collectors.toList());\n\n// Filter + Map\nList<Integer> result = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .map(n -> n * 2)\n    .collect(Collectors.toList());",
    "classes": "public class Person {\n    private String name;\n    private int age;\n    \n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public void introduce() {\n        System.out.println(\"Hi, I'm \" + name);\n    }\n    \n    public boolean isAdult() {\n        return age >= 18;\n    }\n}\n\nPerson person = new Person(\"Alice\", 25);\nperson.introduce();",
    "getters-setters": "public class Person {\n    private String name;\n    private int age;\n    \n    // Getter\n    public String getName() {\n        return name;\n    }\n    \n    // Setter\n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    // Getter\n    public int getAge() {\n        return age;\n    }\n    \n    // Setter\n    public void setAge(int age) {\n        this.age = age;\n    }\n}",
    "inheritance": "public class Animal {\n    protected String name;\n    \n    public Animal(String name) {\n        this.name = name;\n    }\n    \n    public void speak() {\n        System.out.println(\"Some sound\");\n    }\n}\n\npublic class Dog extends Animal {\n    public Dog(String name) {\n        super(name);\n    }\n    \n    @Override\n    public void speak() {\n        System.out.println(name + \" says Woof!\");\n    }\n    \n    public void fetch() {\n        System.out.println(name + \" fetches the ball\");\n    }\n}",
    "modules": "public interface Flyable {\n    void fly();\n}\n\npublic interface Swimmable {\n    void swim();\n}\n\npublic class Duck implements Flyable, Swimmable {\n    @Override\n    public void fly() {\n        System.out.println(\"Duck flies\");\n    }\n    \n    @Override\n    public void swim() {\n        System.out.println(\"Duck swims\");\n    }\n}",
    "file-io": "// Reading entire file\ntry (BufferedReader reader = new BufferedReader(\n        new FileReader(\"data.txt\"))) {\n    String content = reader.lines()\n        .collect(Collectors.joining(\"\\n\"));\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Writing to file\ntry (BufferedWriter writer = new BufferedWriter(\n        new FileWriter(\"output.txt\"))) {\n    writer.write(\"Hello, World!\");\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n// Reading line by line\ntry (BufferedReader reader = new BufferedReader(\n        new FileReader(\"data.txt\"))) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}",
    "json": "import com.fasterxml.jackson.databind.ObjectMapper;\n// or import com.google.gson.Gson;\n\n// Parse JSON string to object\nString jsonString = \"{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30}\";\n\nObjectMapper mapper = new ObjectMapper();\nMap<String, Object> data = mapper.readValue(\n    jsonString, \n    new TypeReference<Map<String, Object>>(){}\n);\n\nString name = (String) data.get(\"name\");\nInteger age = (Integer) data.get(\"age\");\n\n// Convert object to JSON\nPerson person = new Person(\"Bob\", 25);\nString json = mapper.writeValueAsString(person);\n\n// Parse JSON array\nString arrayJson = \"[1, 2, 3, 4, 5]\";\nList<Integer> numbers = mapper.readValue(\n    arrayJson,\n    new TypeReference<List<Integer>>(){}\n);",
    "threading": "// Java threading with synchronized blocks\npublic class Counter {\n    private int count = 0;\n    \n    public synchronized void increment() {\n        count++;\n    }\n    \n    public synchronized int getCount() {\n        return count;\n    }\n}\n\n// Creating threads\nThread thread = new Thread(() -> {\n    System.out.println(\"Running in thread\");\n});\nthread.start();\nthread.join();  // Wait for completion\n\n// Using locks explicitly\nLock lock = new ReentrantLock();\nlock.lock();\ntry {\n    // Critical section\n} finally {\n    lock.unlock();\n}",
    "metaprogramming": "// Java reflection (verbose, limited)\nClass<?> clazz = obj.getClass();\nMethod method = clazz.getMethod(\"methodName\", String.class);\nmethod.invoke(obj, \"argument\");\n\n// Can't easily add methods at runtime\n// Dynamic proxies are complex\n\npublic class Person {\n    // Must define all methods at compile time\n    public String getName() { return name; }\n    public String getEmail() { return email; }\n    // ... lots of repetitive code\n}",
    "duck-typing": "// Java requires interfaces or inheritance\npublic interface Printable {\n    void print();\n}\n\npublic class Document implements Printable {\n    public void print() {\n        System.out.println(\"Printing document\");\n    }\n}\n\npublic class Printer {\n    public void execute(Printable item) {\n        item.print();  // Type safe\n    }\n}\n\n// Must implement interface\nPrinter printer = new Printer();\nprinter.execute(new Document());"
  }
}

