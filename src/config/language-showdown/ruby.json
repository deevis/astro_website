{
  "name": "Ruby",
  "color": "#cc0000",
  "icon": "ruby",
  "history": "Created by Yukihiro Matsumoto (Matz) in 1995 in Japan, Ruby was designed to emphasize programmer happiness and productivity following the principle of least astonishment (POLA). Influenced by Perl, Smalltalk, Eiffel, Ada, and Lisp, Ruby combines functional and imperative programming. The language gained explosive popularity with Ruby on Rails (2004), which revolutionized web development. Ruby 2.0 brought refinements and better performance, while Ruby 3.0 (2020) focused on performance, concurrency, and type checking. Known for its elegant syntax and powerful metaprogramming, Ruby remains beloved by developers who value code readability and developer experience.",
  "keyFeatures": [
    "Pure object-oriented (everything is an object)",
    "Dynamic typing with duck typing",
    "Powerful metaprogramming capabilities",
    "Blocks, procs, and lambdas",
    "Elegant, expressive syntax",
    "Open classes (monkey patching)",
    "Automatic garbage collection",
    "Built-in regex support",
    "Mixin support through modules",
    "Extensive gem ecosystem via RubyGems"
  ],
  "pros": [
    "Exceptional developer productivity",
    "Elegant, readable code",
    "Ruby on Rails for rapid web development",
    "Large, friendly community",
    "Extensive gem library for any task",
    "Flexible and unopinionated",
    "Great for startups and MVPs",
    "Strong metaprogramming for DSLs",
    "Principle of least astonishment",
    "Test-Driven Development culture"
  ],
  "cons": [
    "Slower runtime performance",
    "GIL limits multi-threading (MRI)",
    "Less suitable for CPU-intensive tasks",
    "Smaller job market than Java/Python",
    "Flexibility can lead to inconsistent codebases",
    "Hosting can be more expensive",
    "Less popular for non-web applications",
    "Documentation can be inconsistent"
  ],
  "snippets": {
    "hello-world": "puts \"Hello, World!\"",
    "comments": "# Single-line comment\n\n# Multi-line comments use multiple single-line comments\n# Or you can use =begin/=end blocks (less common)\n\n=begin\nThis is a multi-line comment block\nUseful for commenting out large sections\nBut not commonly used in modern Ruby\n=end\n\n# HEREDOC for multi-line strings\nsql = <<~SQL\n  SELECT *\n  FROM users\n  WHERE age > 18\n  ORDER BY name\nSQL\n\n# Different HEREDOC styles:\n# <<~HEREDOC - squiggly heredoc (strips indentation)\n# <<HEREDOC  - preserves all indentation\n# <<-HEREDOC - allows indented delimiter\n\n# Double-quoted HEREDOC supports interpolation\nname = \"Alice\"\ngreeting = <<~TEXT\n  Hello, #{name}!\n  Welcome to Ruby.\nTEXT\n\n# Single-quoted HEREDOC (no interpolation)\ncode = <<~'CODE'\n  def example\n    puts \"#{interpolation} doesn't work here\"\n  end\nCODE",
    "variables": "# Ruby uses dynamic typing\nname = \"John\"\nage = 30\nitems = []\nPI = 3.14159  # Constants use UPPERCASE\n\n# Everything is an object\nname.class  # => String\nage.class   # => Integer",
    "strings": "name = \"john doe\"\nformatted = name.capitalize\n\n# String interpolation (idiomatic)\nmessage = \"Welcome, #{name}!\"\n\n# Rich string methods\nname.upcase           # \"JOHN DOE\"\nname.split            # [\"john\", \"doe\"]\nname.include?(\"doe\")  # true\n\"hello\" * 3           # \"hellohellohello\"",
    "conditionals": "if age >= 18 && has_license\n  puts \"Can drive\"\nelsif age >= 16\n  puts \"Can get permit\"\nelse\n  puts \"Too young\"\nend\n\n# Ternary\nstatus = age >= 18 ? \"adult\" : \"minor\"\n\n# Statement modifiers (idiomatic for simple conditions)\nputs \"Can drive\" if age >= 18\n\n# Unless (negative if)\nputs \"Too young\" unless age >= 16",
    "case-statements": "# Ruby case/when (cleaner, no break needed)\nday = \"Monday\"\n\nresult = case day\nwhen \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"\n  \"Weekday\"\nwhen \"Saturday\", \"Sunday\"\n  \"Weekend\"\nelse\n  \"Invalid day\"\nend\n\n# Case with ranges\nscore = 85\n\ngrade = case score\nwhen 90..100\n  \"A\"\nwhen 80...90\n  \"B\"\nwhen 70...80\n  \"C\"\nwhen 60...70\n  \"D\"\nelse\n  \"F\"\nend\n\n# Case with regex\ntext = \"hello@example.com\"\n\ntype = case text\nwhen /^\\d+$/\n  \"number\"\nwhen /^[a-z]+$/i\n  \"letters\"\nwhen /@/\n  \"email\"\nelse\n  \"unknown\"\nend\n\n# Case with classes (type checking)\nvalue = 42\n\nresult = case value\nwhen String\n  \"It's a string\"\nwhen Integer\n  \"It's an integer\"\nwhen Array\n  \"It's an array\"\nelse\n  \"Unknown type\"\nend\n\n# Case uses === operator (threequals)\n# Works with any object that implements ===\nwhen (1..10)  # calls (1..10) === value",
    "arrays": "# Ruby arrays are dynamic by default\nnumbers = [1, 2, 3, 4, 5]\n\n# Adding elements\nnumbers << 6           # Append (idiomatic)\nnumbers.push(7)        # Also append\nnumbers.unshift(0)     # Prepend\n\n# Accessing\nfirst = numbers[0]     # or numbers.first\nlast = numbers[-1]     # Negative indices! or numbers.last\n\n# Slicing\nnumbers[1..3]          # [2, 3, 4] - inclusive range\nnumbers[1...3]         # [2, 3] - exclusive range",
    "hashes": "# Ruby Hash (symbol keys are idiomatic)\nages = { john: 30, jane: 28 }\n\n# Or with string keys\nages = { \"john\" => 30, \"jane\" => 28 }\n\n# Access\njohn_age = ages[:john]\nhas_jane = ages.key?(:jane)\n\n# Iteration\nages.each { |name, age| puts \"#{name}: #{age}\" }\n\n# Transform\nages.transform_values { |age| age + 1 }",
    "iteration": "names = [\"Alice\", \"Bob\", \"Charlie\"]\n\n# each is idiomatic for side effects\nnames.each { |name| puts name }\n\n# each_with_index for index access\nnames.each_with_index { |name, i| puts \"#{i}: #{name}\" }\n\n# times for counting\n5.times { |i| puts i }\n\n# upto/downto for ranges\n1.upto(5) { |i| puts i }\n\n# for loop (rarely used, not idiomatic)\nfor name in names\n  puts name\nend",
    "filtering": "numbers = [1, 2, 3, 4, 5]\n\n# select for filtering (like filter)\nevens = numbers.select { |n| n.even? }\n\n# map for transformation\ndoubled = numbers.map { |n| n * 2 }\n\n# Chain operations\nresult = numbers.select(&:even?).map { |n| n * 2 }\n\n# reject (opposite of select)\nodds = numbers.reject(&:even?)\n\n# Other useful methods\nnumbers.any?(&:even?)      # true\nnumbers.all? { |n| n > 0 } # true\nnumbers.find { |n| n > 3 } # 4 (first match)\nnumbers.sum                 # 15",
    "classes": "class Person\n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\n  \n  def introduce\n    puts \"Hi, I'm #{@name}\"\n  end\n  \n  def adult?\n    @age >= 18\n  end\nend\n\nperson = Person.new(\"Alice\", 25)\nperson.introduce",
    "getters-setters": "class Person\n  # Long way (rarely used)\n  def name\n    @name\n  end\n  \n  def name=(value)\n    @name = value\n  end\n  \n  # Idiomatic way - use attr_accessor\n  attr_accessor :name, :age\n  \n  # Or separately:\n  # attr_reader :name    # getter only\n  # attr_writer :age     # setter only\nend\n\nperson = Person.new\nperson.name = \"Alice\"   # Looks like attribute access!\nputs person.name",
    "inheritance": "class Animal\n  attr_reader :name\n  \n  def initialize(name)\n    @name = name\n  end\n  \n  def speak\n    puts \"Some sound\"\n  end\nend\n\nclass Dog < Animal\n  def speak\n    puts \"#{@name} says Woof!\"\n  end\n  \n  def fetch\n    puts \"#{@name} fetches the ball\"\n  end\nend\n\ndog = Dog.new(\"Buddy\")\ndog.speak",
    "modules": "module Flyable\n  def fly\n    puts \"#{self.class} flies\"\n  end\nend\n\nmodule Swimmable\n  def swim\n    puts \"#{self.class} swims\"\n  end\nend\n\nclass Duck\n  include Flyable\n  include Swimmable\nend\n\nduck = Duck.new\nduck.fly   # Duck flies\nduck.swim  # Duck swims\n\n# Can also extend for class methods\nmodule Countable\n  def count\n    @count ||= 0\n  end\nend\n\nclass Item\n  extend Countable\nend",
    "file-io": "# Reading entire file (simple!)\ncontent = File.read(\"data.txt\")\n\n# Writing to file (one-liner)\nFile.write(\"output.txt\", \"Hello, World!\")\n\n# Reading line by line (block auto-closes file)\nFile.foreach(\"data.txt\") do |line|\n  puts line\nend\n\n# Or read all lines into array\nlines = File.readlines(\"data.txt\")\n\n# Block ensures file is closed\nFile.open(\"data.txt\", \"r\") do |file|\n  file.each_line { |line| puts line }\nend\n\n# Appending to file\nFile.open(\"log.txt\", \"a\") do |file|\n  file.puts \"New log entry\"\nend\n\n# Check if file exists\nFile.exist?(\"data.txt\")\n\n# File info\nFile.size(\"data.txt\")\nFile.mtime(\"data.txt\")  # modification time\nFile.directory?(\"path\")",
    "json": "require 'json'\n\n# Parse JSON string (returns Hash or Array)\njson_string = '{\"name\":\"Alice\",\"age\":30}'\ndata = JSON.parse(json_string)\n\nname = data[\"name\"]  # \"Alice\"\nage = data[\"age\"]    # 30\n\n# Parse with symbol keys (more idiomatic)\ndata = JSON.parse(json_string, symbolize_names: true)\nname = data[:name]   # Access with symbols\n\n# Convert to JSON\nperson = { name: \"Bob\", age: 25 }\njson = person.to_json  # or JSON.generate(person)\n\n# Parse JSON array\narray_json = '[1, 2, 3, 4, 5]'\nnumbers = JSON.parse(array_json)  # [1, 2, 3, 4, 5]\n\n# Pretty print JSON\nputs JSON.pretty_generate(person)\n\n# Read JSON from file\ndata = JSON.parse(File.read(\"data.json\"))\n\n# Write JSON to file\nFile.write(\"output.json\", person.to_json)\n\n# Parse with error handling\nbegin\n  data = JSON.parse(invalid_json)\nrescue JSON::ParserError => e\n  puts \"Invalid JSON: #{e.message}\"\nend",
    "threading": "# Ruby threading with Mutex\nclass Counter\n  def initialize\n    @count = 0\n    @mutex = Mutex.new\n  end\n  \n  def increment\n    @mutex.synchronize do\n      @count += 1\n    end\n  end\n  \n  def count\n    @mutex.synchronize { @count }\n  end\nend\n\n# Creating threads\nthread = Thread.new do\n  puts \"Running in thread\"\nend\nthread.join  # Wait for completion\n\n# Multiple threads\nthreads = 5.times.map do |i|\n  Thread.new { puts \"Thread #{i}\" }\nend\nthreads.each(&:join)\n\n# Thread-local variables\nThread.current[:user_id] = 123\n\n# Thread pools (require 'concurrent-ruby' gem)\n# pool = Concurrent::FixedThreadPool.new(5)",
    "metaprogramming": "# Define methods dynamically\nclass Person\n  # Create methods on the fly\n  [:name, :email, :phone].each do |attr|\n    define_method(attr) { instance_variable_get(\"@#{attr}\") }\n    define_method(\"#{attr}=\") { |val| instance_variable_set(\"@#{attr}\", val) }\n  end\nend\n\n# method_missing - catch undefined methods\nclass DynamicModel\n  def method_missing(method, *args)\n    if method.to_s.start_with?('find_by_')\n      attribute = method.to_s.sub('find_by_', '')\n      find_by_attribute(attribute, args.first)\n    else\n      super\n    end\n  end\n  \n  def respond_to_missing?(method, include_private = false)\n    method.to_s.start_with?('find_by_') || super\n  end\nend\n\n# Add methods to existing classes (monkey patching)\nclass String\n  def shout\n    self.upcase + \"!\"\n  end\nend\n\n\"hello\".shout  # \"HELLO!\"\n\n# send - call methods dynamically\nobj.send(:method_name, arg1, arg2)",
    "duck-typing": "# Ruby: \"If it walks like a duck and quacks like a duck...\"\nclass Document\n  def print\n    puts \"Printing document\"\n  end\nend\n\nclass Photo\n  def print\n    puts \"Printing photo\"\n  end\nend\n\nclass Printer\n  def execute(item)\n    item.print  # Don't care about type, just that it responds to print\n  end\nend\n\nprinter = Printer.new\nprinter.execute(Document.new)\nprinter.execute(Photo.new)\n\n# Check if object responds to method\nif item.respond_to?(:print)\n  item.print\nend\n\n# More Ruby-like with blocks\ndef print_items(items)\n  items.each(&:print)\nend"
  }
}

