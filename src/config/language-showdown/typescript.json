{
  "name": "TypeScript",
  "color": "#3178C6",
  "icon": "typescript",
  "history": "Developed by Microsoft and released in 2012, TypeScript was created by Anders Hejlsberg (designer of C# and Turbo Pascal) to address JavaScript's limitations in large applications. TypeScript is a superset of JavaScript that adds optional static typing. It compiles to plain JavaScript and can run anywhere JavaScript runs. Major milestones include generics (1.0), async/await (1.7), strict null checks (2.0), and conditional types (2.8). Adopted by Angular, Vue 3, and countless enterprises, TypeScript has become the de facto standard for large-scale JavaScript development. It brings type safety while maintaining JavaScript's flexibility.",
  "keyFeatures": [
    "Optional static typing",
    "Structural type system (duck typing)",
    "Compiles to JavaScript",
    "Excellent IDE support and autocomplete",
    "Gradual typing (JavaScript is valid TS)",
    "Advanced type features (unions, generics)",
    "Interface and type aliases",
    "Decorators (experimental)",
    "Enum support",
    "Strong integration with modern frameworks"
  ],
  "pros": [
    "Catches errors at compile time",
    "Excellent developer experience",
    "Strong IDE and editor support",
    "Gradual adoption path from JavaScript",
    "Large and growing ecosystem",
    "Backed by Microsoft",
    "Great for large codebases",
    "Improves refactoring confidence",
    "Type-safe without runtime overhead",
    "Cross-platform (Node, browsers, Deno)"
  ],
  "cons": [
    "Additional build step required",
    "Learning curve for type system",
    "Types can be verbose",
    "Still inherits JavaScript quirks",
    "Type definitions for libraries vary in quality",
    "Configuration can be complex",
    "Single-threaded (inherited from JS)",
    "Not truly type-safe (any escape hatch)"
  ],
  "snippets": {
    "hello-world": "console.log(\"Hello, World!\");",
    "comments": "// Single-line comment\n\n/* Multi-line comment\n   can span multiple lines\n   useful for longer explanations */\n\n/**\n * JSDoc comment for documentation\n * @param name - The person's name\n * @returns A greeting message\n */\nfunction greet(name: string): string {\n    return `Hello, ${name}`;\n}\n\n// TypeScript/JavaScript doesn't have traditional HEREDOC\n// Use template literals (backticks) for multi-line strings:\nconst sql = `\n  SELECT *\n  FROM users\n  WHERE age > 18\n  ORDER BY name\n`;\n\n// Template literals support interpolation:\nconst name = \"Alice\";\nconst greeting = `\n  Hello, ${name}!\n  Welcome to TypeScript.\n`;\n\n// Before ES6, concatenation was needed:\nconst longText = \"Line 1\\n\" +\n                 \"Line 2\\n\" +\n                 \"Line 3\";",
    "variables": "// TypeScript has optional type annotations\nlet name: string = \"John\";\nlet age: number = 30;\nlet items: string[] = [];\nconst PI: number = 3.14159;\n\n// Type inference (types optional!)\nlet message = \"Hello\";  // Infers string\nlet count = 42;         // Infers number\n\n// Any type (escape hatch)\nlet flexible: any = \"anything\";\nflexible = 42;  // OK\n\n// Union types\nlet id: string | number;\nid = \"ABC123\";\nid = 42;",
    "strings": "let name: string = \"john doe\";\n\n// Template literals (template strings)\nlet message = `Welcome, ${name}!`;\n\n// String methods (JavaScript)\nname.toUpperCase();      // \"JOHN DOE\"\nname.split(\" \");         // [\"john\", \"doe\"]\nname.includes(\"doe\");    // true\n\"hello\".repeat(3);       // \"hellohellohello\"\n\n// String manipulation\nlet formatted = name\n  .split(\" \")\n  .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n  .join(\" \");\n\n// Tagged templates (advanced)\nfunction tag(strings: TemplateStringsArray, ...values: any[]) {\n  return strings[0] + values[0];\n}\nlet result = tag`Hello ${name}`;",
    "conditionals": "if (age >= 18 && hasLicense) {\n  console.log(\"Can drive\");\n} else if (age >= 16) {\n  console.log(\"Can get permit\");\n} else {\n  console.log(\"Too young\");\n}\n\n// Ternary\nlet status = age >= 18 ? \"adult\" : \"minor\";\n\n// Type guards\nif (typeof id === \"string\") {\n  console.log(id.toUpperCase());  // TS knows id is string here\n} else {\n  console.log(id.toFixed(2));     // TS knows id is number here\n}\n\n// Nullish coalescing\nlet value = possiblyNull ?? \"default\";\n\n// Optional chaining\nlet street = user?.address?.street;",
    "case-statements": "// TypeScript uses JavaScript switch\nlet day: string = \"Monday\";\nlet result: string;\n\nswitch (day) {\n  case \"Monday\":\n  case \"Tuesday\":\n  case \"Wednesday\":\n  case \"Thursday\":\n  case \"Friday\":\n    result = \"Weekday\";\n    break;\n  case \"Saturday\":\n  case \"Sunday\":\n    result = \"Weekend\";\n    break;\n  default:\n    result = \"Invalid day\";\n}\n\n// Pattern matching with type narrowing\ntype Shape = \n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; size: number }\n  | { kind: \"rectangle\"; width: number; height: number };\n\nfunction area(shape: Shape): number {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.size ** 2;\n    case \"rectangle\":\n      return shape.width * shape.height;\n  }\n}\n\n// Discriminated unions are powerful!",
    "arrays": "// Arrays with type annotations\nlet numbers: number[] = [1, 2, 3, 4, 5];\n// Or using generic syntax\nlet items: Array<string> = [\"a\", \"b\", \"c\"];\n\n// Adding elements\nnumbers.push(6);\nnumbers.unshift(0);\n\n// Accessing\nlet first = numbers[0];\nlet last = numbers[numbers.length - 1];\n\n// Array methods (functional)\nlet doubled = numbers.map(n => n * 2);\nlet evens = numbers.filter(n => n % 2 === 0);\nlet sum = numbers.reduce((acc, n) => acc + n, 0);\n\n// Spread operator\nlet copy = [...numbers];\nlet combined = [...numbers, ...items];\n\n// Tuple types (fixed length, mixed types)\nlet tuple: [string, number] = [\"Alice\", 25];",
    "hashes": "// Object literals (like hashes/maps)\nlet ages: { [key: string]: number } = {\n  john: 30,\n  jane: 28\n};\n\n// Or using Map\nlet agesMap = new Map<string, number>();\nagesMap.set(\"john\", 30);\nagesMap.set(\"jane\", 28);\n\n// Access\nlet johnAge = ages[\"john\"];\nlet janeAge = agesMap.get(\"jane\");\n\n// Iteration (object)\nfor (let name in ages) {\n  console.log(`${name}: ${ages[name]}`);\n}\n\n// Iteration (Map)\nagesMap.forEach((age, name) => {\n  console.log(`${name}: ${age}`);\n});\n\n// Record type (typed object)\ntype Ages = Record<string, number>;\nlet typedAges: Ages = { john: 30, jane: 28 };",
    "iteration": "let names: string[] = [\"Alice\", \"Bob\", \"Charlie\"];\n\n// for...of (values)\nfor (let name of names) {\n  console.log(name);\n}\n\n// forEach with arrow function\nnames.forEach((name, index) => {\n  console.log(`${index}: ${name}`);\n});\n\n// for...in (indices/keys)\nfor (let i in names) {\n  console.log(names[i]);\n}\n\n// Traditional for\nfor (let i = 0; i < names.length; i++) {\n  console.log(names[i]);\n}\n\n// while\nwhile (age < 18) {\n  age++;\n}",
    "filtering": "let numbers: number[] = [1, 2, 3, 4, 5];\n\n// Filter\nlet evens = numbers.filter(n => n % 2 === 0);\n\n// Map\nlet doubled = numbers.map(n => n * 2);\n\n// Chain operations\nlet result = numbers\n  .filter(n => n % 2 === 0)\n  .map(n => n * 2);\n\n// Other useful methods\nnumbers.some(n => n % 2 === 0);     // true\nnumbers.every(n => n > 0);          // true\nnumbers.find(n => n > 3);           // 4\nnumbers.reduce((sum, n) => sum + n, 0);  // 15\n\n// Type-safe filtering with type guards\nlet mixed: (string | number)[] = [1, \"two\", 3, \"four\"];\nlet onlyNumbers = mixed.filter((x): x is number => typeof x === \"number\");",
    "classes": "class Person {\n  // Properties with types\n  name: string;\n  age: number;\n  \n  // Constructor\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n  \n  // Methods\n  introduce(): void {\n    console.log(`Hi, I'm ${this.name}`);\n  }\n  \n  isAdult(): boolean {\n    return this.age >= 18;\n  }\n}\n\n// Shorthand constructor (parameter properties)\nclass Student {\n  constructor(\n    public name: string,\n    public grade: number\n  ) {}\n}\n\nlet person = new Person(\"Alice\", 25);\nperson.introduce();",
    "getters-setters": "class Person {\n  private _name: string;\n  private _age: number;\n  \n  constructor(name: string, age: number) {\n    this._name = name;\n    this._age = age;\n  }\n  \n  // Getter\n  get name(): string {\n    return this._name;\n  }\n  \n  // Setter\n  set name(value: string) {\n    if (value.length > 0) {\n      this._name = value;\n    }\n  }\n  \n  get age(): number {\n    return this._age;\n  }\n  \n  set age(value: number) {\n    if (value >= 0) {\n      this._age = value;\n    }\n  }\n}\n\nlet person = new Person(\"Alice\", 25);\nconsole.log(person.name);  // Looks like property!\nperson.age = 26;",
    "inheritance": "class Animal {\n  protected name: string;\n  \n  constructor(name: string) {\n    this.name = name;\n  }\n  \n  speak(): void {\n    console.log(\"Some sound\");\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n  \n  // Override\n  speak(): void {\n    console.log(`${this.name} says Woof!`);\n  }\n  \n  fetch(): void {\n    console.log(`${this.name} fetches the ball`);\n  }\n}\n\nlet dog = new Dog(\"Buddy\");\ndog.speak();\n\n// Abstract classes\nabstract class Shape {\n  abstract area(): number;\n  \n  describe(): void {\n    console.log(`Area: ${this.area()}`);\n  }\n}",
    "modules": "// TypeScript uses interfaces (structural typing!)\n\ninterface Flyable {\n  fly(): void;\n}\n\ninterface Swimmable {\n  swim(): void;\n}\n\n// Implement multiple interfaces\nclass Duck implements Flyable, Swimmable {\n  fly(): void {\n    console.log(\"Duck flies\");\n  }\n  \n  swim(): void {\n    console.log(\"Duck swims\");\n  }\n}\n\nlet duck = new Duck();\nduck.fly();\nduck.swim();\n\n// Structural typing (duck typing but checked!)\nfunction makeFly(thing: Flyable) {\n  thing.fly();\n}\n\n// Any object with fly() works!\nmakeFly(duck);\nmakeFly({ fly: () => console.log(\"Flying\") });",
    "file-io": "// Node.js file I/O (TypeScript for Node)\nimport * as fs from 'fs';\nimport { promises as fsPromises } from 'fs';\n\n// Synchronous (blocking)\nconst content: string = fs.readFileSync('data.txt', 'utf-8');\n\n// Write file\nfs.writeFileSync('output.txt', 'Hello, World!');\n\n// Asynchronous with callbacks\nfs.readFile('data.txt', 'utf-8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n\n// Promises (modern approach)\nasync function readFile(): Promise<string> {\n  const data = await fsPromises.readFile('data.txt', 'utf-8');\n  return data;\n}\n\n// Write with promises\nasync function writeFile(): Promise<void> {\n  await fsPromises.writeFile('output.txt', 'Hello!');\n}\n\n// Check if file exists\nif (fs.existsSync('data.txt')) {\n  console.log('File exists');\n}",
    "json": "// JSON parsing (built-in)\nconst jsonString: string = '{\"name\":\"Alice\",\"age\":30}';\nconst data = JSON.parse(jsonString);\n\n// Type assertion\ninterface Person {\n  name: string;\n  age: number;\n}\n\nconst person = JSON.parse(jsonString) as Person;\nconsole.log(person.name);  // Type-safe!\n\n// Convert to JSON\nconst obj: Person = { name: \"Bob\", age: 25 };\nconst json = JSON.stringify(obj);\n\n// Pretty print\nconst pretty = JSON.stringify(obj, null, 2);\n\n// Type-safe JSON parsing with validation\nfunction parseUser(json: string): Person {\n  const obj = JSON.parse(json);\n  if (typeof obj.name === 'string' && typeof obj.age === 'number') {\n    return obj as Person;\n  }\n  throw new Error('Invalid user data');\n}",
    "threading": "// JavaScript/TypeScript is single-threaded\n// But has async/await for concurrent operations\n\n// Promises\nconst promise = new Promise<string>((resolve, reject) => {\n  setTimeout(() => resolve(\"Done!\"), 1000);\n});\n\npromise.then(result => console.log(result));\n\n// Async/await (cleaner)\nasync function fetchData(): Promise<string> {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  return data;\n}\n\n// Concurrent operations\nasync function concurrent() {\n  const [result1, result2] = await Promise.all([\n    fetchData(),\n    fetchData()\n  ]);\n}\n\n// Web Workers (true parallelism in browser)\nconst worker = new Worker('worker.js');\nworker.postMessage({ data: 'process this' });\nworker.onmessage = (e) => console.log(e.data);",
    "metaprogramming": "// TypeScript has decorators (experimental)\n\n// Class decorator\nfunction sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n\n@sealed\nclass Person {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n// Method decorator\nfunction log(target: any, key: string, descriptor: PropertyDescriptor) {\n  const original = descriptor.value;\n  descriptor.value = function(...args: any[]) {\n    console.log(`Calling ${key} with`, args);\n    return original.apply(this, args);\n  };\n}\n\nclass Calculator {\n  @log\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n\n// Reflect metadata (advanced)\nimport 'reflect-metadata';\n\n// Type information at runtime\ntype Constructor<T> = new(...args: any[]) => T;",
    "duck-typing": "// TypeScript uses structural typing (duck typing with types!)\n\ninterface Printable {\n  print(): void;\n}\n\nclass Document {\n  print(): void {\n    console.log(\"Printing document\");\n  }\n}\n\nclass Photo {\n  print(): void {\n    console.log(\"Printing photo\");\n  }\n}\n\n// Any object with print() method works!\nfunction execute(item: Printable): void {\n  item.print();\n}\n\nexecute(new Document());\nexecute(new Photo());\n\n// Even object literals!\nexecute({\n  print: () => console.log(\"Printing literal\")\n});\n\n// Type guards for runtime checks\nfunction isPrintable(obj: any): obj is Printable {\n  return typeof obj.print === 'function';\n}\n\nif (isPrintable(something)) {\n  something.print();  // Type-safe!\n}"
  }
}


