{
  "name": "C++",
  "color": "#00599C",
  "icon": "cpp",
  "history": "Created by Bjarne Stroustrup in 1979 as 'C with Classes' at Bell Labs, officially named C++ in 1983. C++ extends C with object-oriented features while maintaining backward compatibility. Major standards include C++98, C++11 (massive modernization), C++14, C++17, C++20, and C++23. C++ powers game engines (Unreal, Unity), browsers (Chrome, Firefox), operating systems (Windows, macOS components), and high-performance applications. Known for giving complete control over system resources, C++ remains dominant in performance-critical domains despite its complexity. Modern C++ (C++11 onward) significantly improved safety and expressiveness.",
  "keyFeatures": [
    "Manual memory management with pointers",
    "Multiple inheritance support",
    "Templates for generic programming",
    "Compile to native machine code",
    "Zero-cost abstractions",
    "RAII (Resource Acquisition Is Initialization)",
    "STL (Standard Template Library)",
    "Low-level hardware access",
    "Backward compatible with C",
    "Value and reference semantics"
  ],
  "pros": [
    "Maximum performance and control",
    "Extensive legacy codebase",
    "Powerful template system",
    "Direct hardware access",
    "Huge ecosystem and libraries",
    "Industry standard for systems/games",
    "C++11+ brings modern features",
    "Cross-platform",
    "No garbage collection overhead",
    "Mature, battle-tested"
  ],
  "cons": [
    "Steep learning curve",
    "Manual memory management prone to errors",
    "Undefined behavior pitfalls",
    "Slow compilation times",
    "Complex syntax and semantics",
    "Multiple ways to do the same thing",
    "No standard build system",
    "Header file complexity",
    "Difficult to master fully"
  ],
  "snippets": {
    "hello-world": "#include <iostream>\n\nint main() {\n    std::cout << \"Hello, World!\" << std::endl;\n    return 0;\n}",
    "variables": "// C++ requires explicit types\nstring name = \"John\";\nint age = 30;\nvector<string> items;\nconst double PI = 3.14159;\n\n// Type inference with auto (C++11)\nauto message = \"Hello\";  // Infers const char*\nauto number = 42;        // Infers int\n\n// References (not copies)\nint& ref = age;          // Reference to age",
    "strings": "#include <string>\n#include <algorithm>\n\nstring name = \"john doe\";\n\n// String manipulation\nname[0] = toupper(name[0]);\n\n// String concatenation\nstring message = \"Welcome, \" + name + \"!\";\n\n// String methods\nname.length();\nname.substr(0, 4);           // \"john\"\nname.find(\"doe\");            // Position or npos\ntransform(name.begin(), name.end(), name.begin(), ::toupper);\n\n// C-style strings (char*)\nconst char* cstr = \"Hello\";\n\n// String streams\n#include <sstream>\nstringstream ss;\nss << \"Value: \" << 42;\nstring result = ss.str();",
    "conditionals": "if (age >= 18 && hasLicense) {\n    cout << \"Can drive\" << endl;\n} else if (age >= 16) {\n    cout << \"Can get permit\" << endl;\n} else {\n    cout << \"Too young\" << endl;\n}\n\n// Ternary operator\nstring status = (age >= 18) ? \"adult\" : \"minor\";\n\n// Switch statement\nswitch (age) {\n    case 18:\n        cout << \"Just became adult\" << endl;\n        break;\n    default:\n        cout << \"Other age\" << endl;\n}",
    "case-statements": "// Traditional switch (limited)\nstring day = \"Monday\";\nstring result;\n\n// C++ switch only works with integral types\n// For strings, use if-else chains or maps\nif (day == \"Monday\" || day == \"Tuesday\" || \n    day == \"Wednesday\" || day == \"Thursday\" || day == \"Friday\") {\n    result = \"Weekday\";\n} else if (day == \"Saturday\" || day == \"Sunday\") {\n    result = \"Weekend\";\n} else {\n    result = \"Invalid\";\n}\n\n// Switch with enums (idiomatic)\nenum class Day { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday };\n\nDay today = Day::Monday;\n\nswitch (today) {\n    case Day::Monday:\n    case Day::Tuesday:\n    case Day::Wednesday:\n    case Day::Thursday:\n    case Day::Friday:\n        result = \"Weekday\";\n        break;\n    case Day::Saturday:\n    case Day::Sunday:\n        result = \"Weekend\";\n        break;\n}\n\n// Switch with integers\nint score = 85;\nswitch (score / 10) {\n    case 10:\n    case 9:\n        cout << \"A\" << endl;\n        break;\n    case 8:\n        cout << \"B\" << endl;\n        break;\n    default:\n        cout << \"C or below\" << endl;\n}",
    "arrays": "#include <vector>\n#include <array>\n\n// Fixed-size array (stack)\nint numbers[5] = {1, 2, 3, 4, 5};\n\n// std::array (stack, knows size)\narray<int, 5> arr = {1, 2, 3, 4, 5};\n\n// std::vector (dynamic, heap)\nvector<int> vec = {1, 2, 3, 4, 5};\n\n// Adding elements\nvec.push_back(6);\nvec.insert(vec.begin(), 0);\n\n// Accessing\nint first = vec[0];           // No bounds checking\nint safe = vec.at(0);         // With bounds checking\nint last = vec.back();\n\n// Iterating\nfor (int num : vec) {\n    cout << num << endl;\n}\n\n// Size\nsize_t size = vec.size();",
    "hashes": "#include <map>\n#include <unordered_map>\n\n// std::map (ordered, tree-based)\nmap<string, int> ages;\nages[\"John\"] = 30;\nages[\"Jane\"] = 28;\n\n// std::unordered_map (hash-based, faster)\nunordered_map<string, int> ages_fast;\nages_fast[\"John\"] = 30;\n\n// Access\nint johnAge = ages[\"John\"];\n\n// Safe access\nif (ages.find(\"John\") != ages.end()) {\n    int age = ages[\"John\"];\n}\n\n// Iteration\nfor (const auto& [name, age] : ages) {\n    cout << name << \": \" << age << endl;\n}\n\n// C++17 structured bindings",
    "iteration": "#include <vector>\n\nvector<string> names = {\"Alice\", \"Bob\", \"Charlie\"};\n\n// Range-based for (C++11)\nfor (const auto& name : names) {\n    cout << name << endl;\n}\n\n// Traditional for loop\nfor (size_t i = 0; i < names.size(); i++) {\n    cout << i << \": \" << names[i] << endl;\n}\n\n// Iterator-based\nfor (auto it = names.begin(); it != names.end(); ++it) {\n    cout << *it << endl;\n}\n\n// while loop\nwhile (age < 18) {\n    age++;\n}\n\n// do-while\ndo {\n    age++;\n} while (age < 18);",
    "filtering": "#include <algorithm>\n#include <vector>\n\nvector<int> numbers = {1, 2, 3, 4, 5};\n\n// Filter (using copy_if)\nvector<int> evens;\ncopy_if(numbers.begin(), numbers.end(), back_inserter(evens),\n    [](int n) { return n % 2 == 0; });\n\n// Transform (map)\nvector<int> doubled;\ntransform(numbers.begin(), numbers.end(), back_inserter(doubled),\n    [](int n) { return n * 2; });\n\n// Or with manual loops\nvector<int> result;\nfor (int n : numbers) {\n    if (n % 2 == 0) {\n        result.push_back(n * 2);\n    }\n}\n\n// Using ranges (C++20)\n#include <ranges>\nauto evens = numbers | views::filter([](int n) { return n % 2 == 0; });\nauto doubled = evens | views::transform([](int n) { return n * 2; });",
    "classes": "class Person {\nprivate:\n    string name;\n    int age;\n\npublic:\n    // Constructor\n    Person(string n, int a) : name(n), age(a) {}\n    \n    // Copy constructor\n    Person(const Person& other) : name(other.name), age(other.age) {}\n    \n    // Move constructor (C++11)\n    Person(Person&& other) noexcept \n        : name(move(other.name)), age(other.age) {}\n    \n    // Destructor\n    ~Person() {\n        // Cleanup if needed\n    }\n    \n    void introduce() const {\n        cout << \"Hi, I'm \" << name << endl;\n    }\n    \n    bool isAdult() const {\n        return age >= 18;\n    }\n};\n\nPerson person(\"Alice\", 25);\nperson.introduce();",
    "getters-setters": "class Person {\nprivate:\n    string name;\n    int age;\n\npublic:\n    // Getters (const methods)\n    string getName() const {\n        return name;\n    }\n    \n    int getAge() const {\n        return age;\n    }\n    \n    // Setters\n    void setName(const string& n) {\n        name = n;\n    }\n    \n    void setAge(int a) {\n        if (a >= 0) {\n            age = a;\n        }\n    }\n};\n\n// Or use public fields (not recommended)\nstruct Point {\n    double x;\n    double y;\n};",
    "inheritance": "class Animal {\nprotected:\n    string name;\n\npublic:\n    Animal(string n) : name(n) {}\n    \n    virtual void speak() const {\n        cout << \"Some sound\" << endl;\n    }\n    \n    virtual ~Animal() {}  // Virtual destructor!\n};\n\nclass Dog : public Animal {\npublic:\n    Dog(string n) : Animal(n) {}\n    \n    // Override keyword (C++11)\n    void speak() const override {\n        cout << name << \" says Woof!\" << endl;\n    }\n    \n    void fetch() const {\n        cout << name << \" fetches the ball\" << endl;\n    }\n};\n\nDog dog(\"Buddy\");\ndog.speak();\n\n// Polymorphism\nAnimal* animal = new Dog(\"Max\");\nanimal->speak();  // Calls Dog::speak()\ndelete animal;",
    "modules": "// C++ uses abstract classes for interfaces\n\nclass Flyable {\npublic:\n    virtual void fly() = 0;  // Pure virtual\n    virtual ~Flyable() {}\n};\n\nclass Swimmable {\npublic:\n    virtual void swim() = 0;\n    virtual ~Swimmable() {}\n};\n\n// Multiple inheritance\nclass Duck : public Flyable, public Swimmable {\npublic:\n    void fly() override {\n        cout << \"Duck flies\" << endl;\n    }\n    \n    void swim() override {\n        cout << \"Duck swims\" << endl;\n    }\n};\n\nDuck duck;\nduck.fly();\nduck.swim();\n\n// Diamond problem exists!\n// Use virtual inheritance to solve",
    "file-io": "#include <fstream>\n#include <string>\n\n// Reading entire file\nifstream file(\"data.txt\");\nstringstream buffer;\nbuffer << file.rdbuf();\nstring content = buffer.str();\nfile.close();\n\n// Writing to file\nofstream outfile(\"output.txt\");\noutfile << \"Hello, World!\" << endl;\noutfile.close();\n\n// Reading line by line\nifstream infile(\"data.txt\");\nstring line;\nwhile (getline(infile, line)) {\n    cout << line << endl;\n}\ninfile.close();\n\n// RAII with automatic cleanup\n{\n    ofstream file(\"output.txt\");\n    file << \"Data\";\n    // File automatically closed at end of scope\n}\n\n// C++17 filesystem\n#include <filesystem>\nnamespace fs = std::filesystem;\n\nif (fs::exists(\"data.txt\")) {\n    auto size = fs::file_size(\"data.txt\");\n}",
    "json": "// C++ has no built-in JSON - use libraries\n// Popular: nlohmann/json, RapidJSON, Boost.JSON\n\n#include <nlohmann/json.hpp>\nusing json = nlohmann::json;\n\n// Parse JSON\nstring jsonString = R\"({\"name\":\"Alice\",\"age\":30})\";\nauto data = json::parse(jsonString);\n\nstring name = data[\"name\"];\nint age = data[\"age\"];\n\n// Convert to JSON\njson person;\nperson[\"name\"] = \"Bob\";\nperson[\"age\"] = 25;\nstring json_str = person.dump();\n\n// Pretty print\nstring pretty = person.dump(2);\n\n// With structs\nstruct Person {\n    string name;\n    int age;\n};\n\n// Manual serialization\njson j;\nPerson p{\"Alice\", 30};\nj[\"name\"] = p.name;\nj[\"age\"] = p.age;",
    "threading": "#include <thread>\n#include <mutex>\n#include <vector>\n\n// Create thread\nthread t([]() {\n    cout << \"Running in thread\" << endl;\n});\nt.join();\n\n// Multiple threads with mutex\nmutex mtx;\nint counter = 0;\n\nvector<thread> threads;\nfor (int i = 0; i < 5; i++) {\n    threads.emplace_back([&]() {\n        lock_guard<mutex> lock(mtx);\n        counter++;\n    });\n}\n\nfor (auto& t : threads) {\n    t.join();\n}\n\n// RAII lock guard automatically unlocks\n// unique_lock for more control\nunique_lock<mutex> lock(mtx);\n// ... critical section ...\nlock.unlock();\n\n// Condition variables\n#include <condition_variable>\ncondition_variable cv;",
    "metaprogramming": "// C++ templates (compile-time metaprogramming)\n\ntemplate<typename T>\nT max(T a, T b) {\n    return (a > b) ? a : b;\n}\n\n// Template specialization\ntemplate<>\nconst char* max<const char*>(const char* a, const char* b) {\n    return (strcmp(a, b) > 0) ? a : b;\n}\n\n// Template metaprogramming (factorial at compile time)\ntemplate<int N>\nstruct Factorial {\n    static const int value = N * Factorial<N-1>::value;\n};\n\ntemplate<>\nstruct Factorial<0> {\n    static const int value = 1;\n};\n\nint result = Factorial<5>::value;  // Computed at compile time!\n\n// Variadic templates\ntemplate<typename... Args>\nvoid print(Args... args) {\n    (cout << ... << args) << endl;\n}\n\n// Concepts (C++20)\ntemplate<typename T>\nconcept Printable = requires(T t) {\n    { cout << t } -> same_as<ostream&>;\n};",
    "duck-typing": "// C++ uses static typing with templates and inheritance\n\n// Abstract interface\nclass Printable {\npublic:\n    virtual void print() const = 0;\n    virtual ~Printable() {}\n};\n\nclass Document : public Printable {\npublic:\n    void print() const override {\n        cout << \"Printing document\" << endl;\n    }\n};\n\nclass Photo : public Printable {\npublic:\n    void print() const override {\n        cout << \"Printing photo\" << endl;\n    }\n};\n\n// Polymorphism with pointers/references\nvoid execute(const Printable& item) {\n    item.print();\n}\n\n// Or with templates (compile-time polymorphism)\ntemplate<typename T>\nvoid execute_template(const T& item) {\n    item.print();  // Requires print() method\n}\n\nexecute(Document());\nexecute(Photo());"
  }
}

